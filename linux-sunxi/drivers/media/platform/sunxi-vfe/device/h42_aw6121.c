/*
 * H42_AW6121 sensor driver
 *
 * Copyright (C) 2015 AllWinnertech Ltd.
 * Author: raymonxiu
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether express or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/clk.h>
#include <media/v4l2-device.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-mediabus.h>
#include <linux/io.h>
#include <linux/miscdevice.h>

#include "camera.h"
#include "sensor_helper.h"

#define SYS_FS_RW
#define FIXED_FRAME_RATE

MODULE_AUTHOR("raymonxiu");
MODULE_DESCRIPTION("A low-level driver for H42_AW6121 sensors");
MODULE_LICENSE("GPL");

static struct v4l2_subdev *h42_aw6121;


#define DEV_DBG_EN   		0
#if (DEV_DBG_EN == 1)
#define vfe_dev_dbg(x, arg...) printk("[CSI_DEBUG][H42_AW6121]"x, ##arg)
#else
#define vfe_dev_dbg(x, arg...)
#endif
#define vfe_dev_err(x, arg...) printk("[CSI_ERR][H42_AW6121]"x, ##arg)
#define vfe_dev_print(x, arg...) printk("[CSI][H42_AW6121]"x, ##arg)

#define LOG_ERR_RET(x)  { \
							int ret;  \
							ret = x; \
							if (ret < 0) {\
								vfe_dev_err("error at %s\n", __func__);  \
								return ret; \
							} \
						}

#define MCLK (24*1000*1000)
#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_LOW
#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
#define V4L2_IDENT_SENSOR 0x1410


#define CSI_STBY_ON			1
#define CSI_STBY_OFF 		0
#define CSI_RST_ON			1
#define CSI_RST_OFF			0
#define CSI_PWR_ON			1
#define CSI_PWR_OFF			0

#define regval_list reg_list_a16_d8
#define REG_DLY  0xffff

#define SENSOR_FRAME_RATE 15

#define I2C_ADDR 0x54
#define SENSOR_NAME "h42_aw6121"

static __u32 reg_step = 2;
struct timer_list s_timer;
struct sensor_format_struct;

struct cfg_array {
	struct regval_list *regs;
	int size;
};

static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct sensor_info, sd);
}

void h42_sensor_init(struct v4l2_subdev *sd);
__s32 block_write(struct v4l2_subdev *sd, __u16 *reg, __u32 length);

#define NTK_FIX_FPS

#define DISP_720P

static struct regval_list sensor_default_regs[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x80},
	{0x001c, 0xff},
	{0x001d, 0xff},
	{0x001e, 0xff},
	{0x001f, 0xff},
	{0x0018, 0x00},
	{0x0019, 0x00},
	{0x001a, 0x00},
	{0x001b, 0x00},
	{0x00bc, 0x11},
	{0x00bd, 0x00},
	{0x00be, 0x00},
	{0x00bf, 0x00},
	{0x0020, 0x01},
	{0x0021, 0x0e},
	{0x0022, 0x00},
	{0x0023, 0x00},
	{0x0024, 0x03},
	{0x0025, 0x0e},
	{0x0026, 0x01},
	{0x0027, 0x0e},
	{0x0030, 0x51},
	{0x0031, 0x20},
	{0x0032, 0x70},
	{0x0033, 0x11},
	{0xfffd, 0x80},
	{0xfffe, 0x25},
	{0x0002, 0x80},
	{0x6007, 0x03},

	{0xfffd, 0x80},
	{0xfffe, 0x14},
	{0x1000, 0x70},
	{0x1001, 0x4d},
	{0x1002, 0x65},
	{0x1003, 0x61},
	{0x1004, 0x6e},
	{0x1005, 0x59},
	{0x1006, 0x20},
	{0x1007, 0x3d},
	{0x1008, 0x20},
	{0x1009, 0x25},
	{0x100a, 0x64},
	{0x100b, 0x20},
	{0x100c, 0x70},
	{0x100d, 0x41},
	{0x100e, 0x45},
	{0x100f, 0x41},
	{0x1010, 0x47},
	{0x1011, 0x43},
	{0x1012, 0x6f},
	{0x1013, 0x6e},
	{0x1014, 0x74},
	{0x1015, 0x72},
	{0x1016, 0x6f},
	{0x1017, 0x6c},
	{0x1018, 0x2d},
	{0x1019, 0x3e},
	{0x101a, 0x6e},
	{0x101b, 0x54},
	{0x101c, 0x61},
	{0x101d, 0x72},
	{0x101e, 0x67},
	{0x101f, 0x65},
	{0x1020, 0x74},
	{0x1021, 0x59},
	{0x1022, 0x3d},
	{0x1023, 0x25},
	{0x1024, 0x64},
	{0x1025, 0x0a},
	{0x1026, 0x00},
	{0x1027, 0x00},

	{0x1028, 0x48},
	{0x1029, 0x50},
	{0x102a, 0x40},
	{0x102b, 0x48},
	{0x102c, 0x38},
	{0x102d, 0x40},
	{0x102e, 0x30},
	{0x102f, 0x38},
	{0x1030, 0x2d},
	{0x1031, 0x34},
	{0x1032, 0x28},
	{0x1033, 0x30},

	{0x1034, 0x9c},
	{0x1035, 0x21},
	{0x1036, 0xff},
	{0x1037, 0xf8},
	{0x1038, 0xd4},
	{0x1039, 0x01},
	{0x103a, 0x48},
	{0x103b, 0x00},
	{0x103c, 0xd4},
	{0x103d, 0x01},
	{0x103e, 0x50},
	{0x103f, 0x04},
	{0x1040, 0x19},
	{0x1041, 0x40},
	{0x1042, 0x00},
	{0x1043, 0x14},
	{0x1044, 0xa9},
	{0x1045, 0x4a},
	{0x1046, 0x00},
	{0x1047, 0x18},
	{0x1048, 0x84},
	{0x1049, 0x6a},
	{0x104a, 0x00},
	{0x104b, 0x00},
	{0x104c, 0x84},
	{0x104d, 0x63},
	{0x104e, 0x00},
	{0x104f, 0x08},
	{0x1050, 0xbc},
	{0x1051, 0x43},
	{0x1052, 0x00},
	{0x1053, 0x1f},
	{0x1054, 0x0c},
	{0x1055, 0x00},
	{0x1056, 0x00},
	{0x1057, 0x05},
	{0x1058, 0x9c},
	{0x1059, 0x83},
	{0x105a, 0xff},
	{0x105b, 0xf0},
	{0x105c, 0xbc},
	{0x105d, 0x43},
	{0x105e, 0x00},
	{0x105f, 0x3f},
	{0x1060, 0x10},
	{0x1061, 0x00},
	{0x1062, 0x00},
	{0x1063, 0x7d},
	{0x1064, 0xb8},
	{0x1065, 0x83},
	{0x1066, 0x00},
	{0x1067, 0x41},
	{0x1068, 0x84},
	{0x1069, 0x6a},
	{0x106a, 0x00},
	{0x106b, 0x00},
	{0x106c, 0xa4},
	{0x106d, 0x84},
	{0x106e, 0x00},
	{0x106f, 0xff},
	{0x1070, 0x8c},
	{0x1071, 0xa3},
	{0x1072, 0x00},
	{0x1073, 0x1f},
	{0x1074, 0x07},
	{0x1075, 0xfb},
	{0x1076, 0x23},
	{0x1077, 0x71},
	{0x1078, 0x94},
	{0x1079, 0x63},
	{0x107a, 0x00},
	{0x107b, 0x40},
	{0x107c, 0x18},
	{0x107d, 0x60},
	{0x107e, 0x80},
	{0x107f, 0x80},
	{0x1080, 0x85},
	{0x1081, 0x0a},
	{0x1082, 0x00},
	{0x1083, 0x00},
	{0x1084, 0xa8},
	{0x1085, 0x83},
	{0x1086, 0x01},
	{0x1087, 0x24},
	{0x1088, 0x84},
	{0x1089, 0xc8},
	{0x108a, 0x00},
	{0x108b, 0x08},
	{0x108c, 0x8d},
	{0x108d, 0xe4},
	{0x108e, 0x00},
	{0x108f, 0x00},
	{0x1090, 0xa8},
	{0x1091, 0xa3},
	{0x1092, 0x01},
	{0x1093, 0x25},
	{0x1094, 0xa8},
	{0x1095, 0xe3},
	{0x1096, 0x01},
	{0x1097, 0x26},
	{0x1098, 0x84},
	{0x1099, 0x88},
	{0x109a, 0x00},
	{0x109b, 0x04},
	{0x109c, 0x8e},
	{0x109d, 0x25},
	{0x109e, 0x00},
	{0x109f, 0x00},
	{0x10a0, 0xe2},
	{0x10a1, 0xa6},
	{0x10a2, 0x23},
	{0x10a3, 0x06},
	{0x10a4, 0xa9},
	{0x10a5, 0x63},
	{0x10a6, 0x01},
	{0x10a7, 0x3f},
	{0x10a8, 0x8e},
	{0x10a9, 0x67},
	{0x10aa, 0x00},
	{0x10ab, 0x00},
	{0x10ac, 0xa8},
	{0x10ad, 0xa3},
	{0x10ae, 0x01},
	{0x10af, 0x3c},
	{0x10b0, 0xa9},
	{0x10b1, 0xa3},
	{0x10b2, 0x01},
	{0x10b3, 0x2d},
	{0x10b4, 0xa8},
	{0x10b5, 0xe3},
	{0x10b6, 0x01},
	{0x10b7, 0x3e},
	{0x10b8, 0x8c},
	{0x10b9, 0x85},
	{0x10ba, 0x00},
	{0x10bb, 0x00},
	{0x10bc, 0xa8},
	{0x10bd, 0xc3},
	{0x10be, 0x01},
	{0x10bf, 0x3d},
	{0x10c0, 0x8c},
	{0x10c1, 0xa6},
	{0x10c2, 0x00},
	{0x10c3, 0x00},
	{0x10c4, 0xb8},
	{0x10c5, 0xc4},
	{0x10c6, 0x00},
	{0x10c7, 0x18},
	{0x10c8, 0xb8},
	{0x10c9, 0x65},
	{0x10ca, 0x00},
	{0x10cb, 0x10},
	{0x10cc, 0x8c},
	{0x10cd, 0x87},
	{0x10ce, 0x00},
	{0x10cf, 0x00},
	{0x10d0, 0xe0},
	{0x10d1, 0x66},
	{0x10d2, 0x18},
	{0x10d3, 0x00},
	{0x10d4, 0x8c},
	{0x10d5, 0xeb},
	{0x10d6, 0x00},
	{0x10d7, 0x00},
	{0x10d8, 0xb8},
	{0x10d9, 0x84},
	{0x10da, 0x00},
	{0x10db, 0x08},
	{0x10dc, 0x8c},
	{0x10dd, 0xad},
	{0x10de, 0x00},
	{0x10df, 0x00},
	{0x10e0, 0xe0},
	{0x10e1, 0x63},
	{0x10e2, 0x20},
	{0x10e3, 0x00},
	{0x10e4, 0x8c},
	{0x10e5, 0xc8},
	{0x10e6, 0x00},
	{0x10e7, 0x1c},
	{0x10e8, 0xa8},
	{0x10e9, 0x91},
	{0x10ea, 0x00},
	{0x10eb, 0x00},
	{0x10ec, 0xbc},
	{0x10ed, 0x05},
	{0x10ee, 0x00},
	{0x10ef, 0x00},
	{0x10f0, 0x10},
	{0x10f1, 0x00},
	{0x10f2, 0x00},
	{0x10f3, 0x1f},
	{0x10f4, 0xe0},
	{0x10f5, 0xe3},
	{0x10f6, 0x38},
	{0x10f7, 0x00},
	{0x10f8, 0xe0},
	{0x10f9, 0xb3},
	{0x10fa, 0x88},
	{0x10fb, 0x00},
	{0x10fc, 0xe4},
	{0x10fd, 0x71},
	{0x10fe, 0x98},
	{0x10ff, 0x00},
	{0x1100, 0x10},
	{0x1101, 0x00},
	{0x1102, 0x00},
	{0x1103, 0x52},
	{0x1104, 0x9d},
	{0x1105, 0x00},
	{0x1106, 0x00},
	{0x1107, 0x00},
	{0x1108, 0xa4},
	{0x1109, 0x66},
	{0x110a, 0xff},
	{0x110b, 0xff},
	{0x110c, 0xe4},
	{0x110d, 0x43},
	{0x110e, 0x28},
	{0x110f, 0x00},
	{0x1110, 0x10},
	{0x1111, 0x00},
	{0x1112, 0x00},
	{0x1113, 0x06},
	{0x1114, 0xe4},
	{0x1115, 0xb5},
	{0x1116, 0x38},
	{0x1117, 0x00},
	{0x1118, 0xe4},
	{0x1119, 0x83},
	{0x111a, 0x40},
	{0x111b, 0x00},
	{0x111c, 0x0c},
	{0x111d, 0x00},
	{0x111e, 0x00},
	{0x111f, 0x82},
	{0x1120, 0xbc},
	{0x1121, 0x24},
	{0x1122, 0x00},
	{0x1123, 0x00},
	{0x1124, 0xe4},
	{0x1125, 0xb5},
	{0x1126, 0x38},
	{0x1127, 0x00},
	{0x1128, 0x10},
	{0x1129, 0x00},
	{0x112a, 0x00},
	{0x112b, 0x06},
	{0x112c, 0x18},
	{0x112d, 0x60},
	{0x112e, 0x80},
	{0x112f, 0x21},
	{0x1130, 0xe4},
	{0x1131, 0x66},
	{0x1132, 0x78},
	{0x1133, 0x00},
	{0x1134, 0x0c},
	{0x1135, 0x00},
	{0x1136, 0x00},
	{0x1137, 0x80},
	{0x1138, 0x9c},
	{0x1139, 0xe0},
	{0x113a, 0xff},
	{0x113b, 0x80},
	{0x113c, 0x18},
	{0x113d, 0x60},
	{0x113e, 0x80},
	{0x113f, 0x21},
	{0x1140, 0xa8},
	{0x1141, 0x83},
	{0x1142, 0x00},
	{0x1143, 0x83},
	{0x1144, 0xa8},
	{0x1145, 0xa3},
	{0x1146, 0x01},
	{0x1147, 0x9c},
	{0x1148, 0x8c},
	{0x1149, 0x64},
	{0x114a, 0x00},
	{0x114b, 0x00},
	{0x114c, 0xa4},
	{0x114d, 0x63},
	{0x114e, 0x00},
	{0x114f, 0x7f},
	{0x1150, 0xd8},
	{0x1151, 0x04},
	{0x1152, 0x18},
	{0x1153, 0x00},
	{0x1154, 0x8c},
	{0x1155, 0x65},
	{0x1156, 0x00},
	{0x1157, 0x00},
	{0x1158, 0xa4},
	{0x1159, 0x63},
	{0x115a, 0x00},
	{0x115b, 0xef},
	{0x115c, 0xd8},
	{0x115d, 0x05},
	{0x115e, 0x18},
	{0x115f, 0x00},
	{0x1160, 0x18},
	{0x1161, 0x60},
	{0x1162, 0x80},
	{0x1163, 0x80},
	{0x1164, 0xa8},
	{0x1165, 0x63},
	{0x1166, 0x01},
	{0x1167, 0x25},
	{0x1168, 0xd8},
	{0x1169, 0x03},
	{0x116a, 0x30},
	{0x116b, 0x00},
	{0x116c, 0x84},
	{0x116d, 0xca},
	{0x116e, 0x00},
	{0x116f, 0x00},
	{0x1170, 0x8c},
	{0x1171, 0x66},
	{0x1172, 0x00},
	{0x1173, 0x00},
	{0x1174, 0xbc},
	{0x1175, 0x23},
	{0x1176, 0x00},
	{0x1177, 0x01},
	{0x1178, 0x0c},
	{0x1179, 0x00},
	{0x117a, 0x00},
	{0x117b, 0x4b},
	{0x117c, 0x18},
	{0x117d, 0x60},
	{0x117e, 0x80},
	{0x117f, 0x21},
	{0x1180, 0xa8},
	{0x1181, 0x83},
	{0x1182, 0x11},
	{0x1183, 0x0a},
	{0x1184, 0xa8},
	{0x1185, 0xa3},
	{0x1186, 0x11},
	{0x1187, 0x0b},
	{0x1188, 0x8c},
	{0x1189, 0x64},
	{0x118a, 0x00},
	{0x118b, 0x00},
	{0x118c, 0x8c},
	{0x118d, 0x85},
	{0x118e, 0x00},
	{0x118f, 0x00},
	{0x1190, 0xb8},
	{0x1191, 0x63},
	{0x1192, 0x00},
	{0x1193, 0x08},
	{0x1194, 0xe0},
	{0x1195, 0x63},
	{0x1196, 0x20},
	{0x1197, 0x00},
	{0x1198, 0xd4},
	{0x1199, 0x06},
	{0x119a, 0x18},
	{0x119b, 0x08},
	{0x119c, 0x84},
	{0x119d, 0x6a},
	{0x119e, 0x00},
	{0x119f, 0x00},
	{0x11a0, 0x84},
	{0x11a1, 0x63},
	{0x11a2, 0x00},
	{0x11a3, 0x08},
	{0x11a4, 0xbc},
	{0x11a5, 0x43},
	{0x11a6, 0x00},
	{0x11a7, 0x1e},
	{0x11a8, 0x10},
	{0x11a9, 0x00},
	{0x11aa, 0x00},
	{0x11ab, 0x12},
	{0x11ac, 0xbc},
	{0x11ad, 0x43},
	{0x11ae, 0x00},
	{0x11af, 0x2e},
	{0x11b0, 0x18},
	{0x11b1, 0x60},
	{0x11b2, 0x00},
	{0x11b3, 0x14},
	{0x11b4, 0xa8},
	{0x11b5, 0x63},
	{0x11b6, 0x10},
	{0x11b7, 0x28},
	{0x11b8, 0x8c},
	{0x11b9, 0x83},
	{0x11ba, 0x00},
	{0x11bb, 0x00},
	{0x11bc, 0x18},
	{0x11bd, 0x60},
	{0x11be, 0x00},
	{0x11bf, 0x14},
	{0x11c0, 0xa8},
	{0x11c1, 0x63},
	{0x11c2, 0x10},
	{0x11c3, 0x29},
	{0x11c4, 0x8c},
	{0x11c5, 0x63},
	{0x11c6, 0x00},
	{0x11c7, 0x00},
	{0x11c8, 0xa8},
	{0x11c9, 0xa4},
	{0x11ca, 0x00},
	{0x11cb, 0x00},
	{0x11cc, 0xa8},
	{0x11cd, 0x83},
	{0x11ce, 0x00},
	{0x11cf, 0x00},
	{0x11d0, 0x18},
	{0x11d1, 0x60},
	{0x11d2, 0x80},
	{0x11d3, 0x80},
	{0x11d4, 0xa8},
	{0x11d5, 0x63},
	{0x11d6, 0x01},
	{0x11d7, 0x2c},
	{0x11d8, 0x8c},
	{0x11d9, 0x63},
	{0x11da, 0x00},
	{0x11db, 0x00},
	{0x11dc, 0xbc},
	{0x11dd, 0x23},
	{0x11de, 0x00},
	{0x11df, 0x01},
	{0x11e0, 0x10},
	{0x11e1, 0x00},
	{0x11e2, 0x00},
	{0x11e3, 0x70},
	{0x11e4, 0x18},
	{0x11e5, 0x60},
	{0x11e6, 0x80},
	{0x11e7, 0x21},
	{0x11e8, 0x00},
	{0x11e9, 0x00},
	{0x11ea, 0x00},
	{0x11eb, 0x13},
	{0x11ec, 0xa8},
	{0x11ed, 0xc3},
	{0x11ee, 0x05},
	{0x11ef, 0x81},
	{0x11f0, 0x10},
	{0x11f1, 0x00},
	{0x11f2, 0x00},
	{0x11f3, 0x22},
	{0x11f4, 0xbc},
	{0x11f5, 0x43},
	{0x11f6, 0x00},
	{0x11f7, 0x3e},
	{0x11f8, 0x18},
	{0x11f9, 0x60},
	{0x11fa, 0x00},
	{0x11fb, 0x14},
	{0x11fc, 0xa8},
	{0x11fd, 0x63},
	{0x11fe, 0x10},
	{0x11ff, 0x2a},
	{0x1200, 0x8c},
	{0x1201, 0x83},
	{0x1202, 0x00},
	{0x1203, 0x00},
	{0x1204, 0x18},
	{0x1205, 0x60},
	{0x1206, 0x00},
	{0x1207, 0x14},
	{0x1208, 0xa8},
	{0x1209, 0x63},
	{0x120a, 0x10},
	{0x120b, 0x2b},
	{0x120c, 0xa8},
	{0x120d, 0xa4},
	{0x120e, 0x00},
	{0x120f, 0x00},
	{0x1210, 0x8c},
	{0x1211, 0x63},
	{0x1212, 0x00},
	{0x1213, 0x00},
	{0x1214, 0xa8},
	{0x1215, 0x83},
	{0x1216, 0x00},
	{0x1217, 0x00},
	{0x1218, 0x18},
	{0x1219, 0x60},
	{0x121a, 0x80},
	{0x121b, 0x80},
	{0x121c, 0xa8},
	{0x121d, 0x63},
	{0x121e, 0x01},
	{0x121f, 0x2c},
	{0x1220, 0x8c},
	{0x1221, 0x63},
	{0x1222, 0x00},
	{0x1223, 0x00},
	{0x1224, 0xbc},
	{0x1225, 0x23},
	{0x1226, 0x00},
	{0x1227, 0x01},
	{0x1228, 0x10},
	{0x1229, 0x00},
	{0x122a, 0x00},
	{0x122b, 0x5e},
	{0x122c, 0x18},
	{0x122d, 0x60},
	{0x122e, 0x80},
	{0x122f, 0x21},
	{0x1230, 0xa8},
	{0x1231, 0xc3},
	{0x1232, 0x05},
	{0x1233, 0x81},
	{0x1234, 0xa8},
	{0x1235, 0x63},
	{0x1236, 0x05},
	{0x1237, 0x82},
	{0x1238, 0xd8},
	{0x1239, 0x06},
	{0x123a, 0x28},
	{0x123b, 0x00},
	{0x123c, 0xd8},
	{0x123d, 0x03},
	{0x123e, 0x20},
	{0x123f, 0x00},
	{0x1240, 0x00},
	{0x1241, 0x00},
	{0x1242, 0x00},
	{0x1243, 0x58},
	{0x1244, 0x15},
	{0x1245, 0x00},
	{0x1246, 0x00},
	{0x1247, 0x00},
	{0x1248, 0xe0},
	{0x1249, 0x71},
	{0x124a, 0x98},
	{0x124b, 0x02},
	{0x124c, 0x03},
	{0x124d, 0xff},
	{0x124e, 0xff},
	{0x124f, 0xaf},
	{0x1250, 0xa5},
	{0x1251, 0x03},
	{0x1252, 0xff},
	{0x1253, 0xff},
	{0x1254, 0xbc},
	{0x1255, 0x43},
	{0x1256, 0x00},
	{0x1257, 0x7f},
	{0x1258, 0x0c},
	{0x1259, 0x00},
	{0x125a, 0x00},
	{0x125b, 0x31},
	{0x125c, 0xb8},
	{0x125d, 0x83},
	{0x125e, 0x00},
	{0x125f, 0x42},
	{0x1260, 0xbc},
	{0x1261, 0x43},
	{0x1262, 0x00},
	{0x1263, 0xff},
	{0x1264, 0x10},
	{0x1265, 0x00},
	{0x1266, 0x00},
	{0x1267, 0x45},
	{0x1268, 0x15},
	{0x1269, 0x00},
	{0x126a, 0x00},
	{0x126b, 0x00},
	{0x126c, 0xb8},
	{0x126d, 0x83},
	{0x126e, 0x00},
	{0x126f, 0x43},
	{0x1270, 0x03},
	{0x1271, 0xff},
	{0x1272, 0xff},
	{0x1273, 0x7e},
	{0x1274, 0x9c},
	{0x1275, 0x84},
	{0x1276, 0x00},
	{0x1277, 0x20},
	{0x1278, 0x0c},
	{0x1279, 0x00},
	{0x127a, 0x00},
	{0x127b, 0x22},
	{0x127c, 0xbc},
	{0x127d, 0x43},
	{0x127e, 0x00},
	{0x127f, 0x4e},
	{0x1280, 0x10},
	{0x1281, 0x00},
	{0x1282, 0x00},
	{0x1283, 0x35},
	{0x1284, 0xbc},
	{0x1285, 0x43},
	{0x1286, 0x00},
	{0x1287, 0x5e},
	{0x1288, 0x18},
	{0x1289, 0x60},
	{0x128a, 0x00},
	{0x128b, 0x14},
	{0x128c, 0xa8},
	{0x128d, 0x63},
	{0x128e, 0x10},
	{0x128f, 0x2e},
	{0x1290, 0x8c},
	{0x1291, 0x83},
	{0x1292, 0x00},
	{0x1293, 0x00},
	{0x1294, 0x18},
	{0x1295, 0x60},
	{0x1296, 0x00},
	{0x1297, 0x14},
	{0x1298, 0xa8},
	{0x1299, 0x63},
	{0x129a, 0x10},
	{0x129b, 0x2f},
	{0x129c, 0x03},
	{0x129d, 0xff},
	{0x129e, 0xff},
	{0x129f, 0xca},
	{0x12a0, 0x15},
	{0x12a1, 0x00},
	{0x12a2, 0x00},
	{0x12a3, 0x00},
	{0x12a4, 0x18},
	{0x12a5, 0xa0},
	{0x12a6, 0x80},
	{0x12a7, 0x14},
	{0x12a8, 0xa8},
	{0x12a9, 0x65},
	{0x12aa, 0x00},
	{0x12ab, 0x2a},
	{0x12ac, 0x8c},
	{0x12ad, 0x63},
	{0x12ae, 0x00},
	{0x12af, 0x00},
	{0x12b0, 0xbc},
	{0x12b1, 0xa3},
	{0x12b2, 0x00},
	{0x12b3, 0x07},
	{0x12b4, 0x10},
	{0x12b5, 0x00},
	{0x12b6, 0x00},
	{0x12b7, 0x0b},
	{0x12b8, 0x18},
	{0x12b9, 0x80},
	{0x12ba, 0x80},
	{0x12bb, 0x21},
	{0x12bc, 0x18},
	{0x12bd, 0x60},
	{0x12be, 0x80},
	{0x12bf, 0x21},
	{0x12c0, 0x9c},
	{0x12c1, 0xa0},
	{0x12c2, 0x00},
	{0x12c3, 0x07},
	{0x12c4, 0xa8},
	{0x12c5, 0x83},
	{0x12c6, 0x11},
	{0x12c7, 0x0a},
	{0x12c8, 0x9c},
	{0x12c9, 0xe0},
	{0x12ca, 0xff},
	{0x12cb, 0xff},
	{0x12cc, 0xa8},
	{0x12cd, 0x63},
	{0x12ce, 0x11},
	{0x12cf, 0x0b},
	{0x12d0, 0xd8},
	{0x12d1, 0x04},
	{0x12d2, 0x28},
	{0x12d3, 0x00},
	{0x12d4, 0xd8},
	{0x12d5, 0x03},
	{0x12d6, 0x38},
	{0x12d7, 0x00},
	{0x12d8, 0x03},
	{0x12d9, 0xff},
	{0x12da, 0xff},
	{0x12db, 0xb2},
	{0x12dc, 0x84},
	{0x12dd, 0x6a},
	{0x12de, 0x00},
	{0x12df, 0x00},
	{0x12e0, 0xa8},
	{0x12e1, 0xc5},
	{0x12e2, 0x00},
	{0x12e3, 0x2b},
	{0x12e4, 0xa8},
	{0x12e5, 0xa4},
	{0x12e6, 0x11},
	{0x12e7, 0x0a},
	{0x12e8, 0xd8},
	{0x12e9, 0x05},
	{0x12ea, 0x18},
	{0x12eb, 0x00},
	{0x12ec, 0xa8},
	{0x12ed, 0x84},
	{0x12ee, 0x11},
	{0x12ef, 0x0b},
	{0x12f0, 0x8c},
	{0x12f1, 0x66},
	{0x12f2, 0x00},
	{0x12f3, 0x00},
	{0x12f4, 0xd8},
	{0x12f5, 0x04},
	{0x12f6, 0x18},
	{0x12f7, 0x00},
	{0x12f8, 0x03},
	{0x12f9, 0xff},
	{0x12fa, 0xff},
	{0x12fb, 0xaa},
	{0x12fc, 0x84},
	{0x12fd, 0x6a},
	{0x12fe, 0x00},
	{0x12ff, 0x00},
	{0x1300, 0x18},
	{0x1301, 0x60},
	{0x1302, 0x00},
	{0x1303, 0x14},
	{0x1304, 0xa8},
	{0x1305, 0x63},
	{0x1306, 0x10},
	{0x1307, 0x2c},
	{0x1308, 0x8c},
	{0x1309, 0x83},
	{0x130a, 0x00},
	{0x130b, 0x00},
	{0x130c, 0x18},
	{0x130d, 0x60},
	{0x130e, 0x00},
	{0x130f, 0x14},
	{0x1310, 0xa8},
	{0x1311, 0x63},
	{0x1312, 0x10},
	{0x1313, 0x2d},
	{0x1314, 0x03},
	{0x1315, 0xff},
	{0x1316, 0xff},
	{0x1317, 0xac},
	{0x1318, 0x15},
	{0x1319, 0x00},
	{0x131a, 0x00},
	{0x131b, 0x00},
	{0x131c, 0x03},
	{0x131d, 0xff},
	{0x131e, 0xff},
	{0x131f, 0x53},
	{0x1320, 0x9c},
	{0x1321, 0x84},
	{0x1322, 0x00},
	{0x1323, 0x10},
	{0x1324, 0x13},
	{0x1325, 0xff},
	{0x1326, 0xff},
	{0x1327, 0x92},
	{0x1328, 0xe4},
	{0x1329, 0xb5},
	{0x132a, 0x38},
	{0x132b, 0x00},
	{0x132c, 0x03},
	{0x132d, 0xff},
	{0x132e, 0xff},
	{0x132f, 0x7f},
	{0x1330, 0x15},
	{0x1331, 0x00},
	{0x1332, 0x00},
	{0x1333, 0x00},
	{0x1334, 0xa8},
	{0x1335, 0x83},
	{0x1336, 0x00},
	{0x1337, 0x83},
	{0x1338, 0xa8},
	{0x1339, 0xa3},
	{0x133a, 0x01},
	{0x133b, 0x9c},
	{0x133c, 0x8c},
	{0x133d, 0x64},
	{0x133e, 0x00},
	{0x133f, 0x00},
	{0x1340, 0xe0},
	{0x1341, 0x63},
	{0x1342, 0x38},
	{0x1343, 0x04},
	{0x1344, 0xd8},
	{0x1345, 0x04},
	{0x1346, 0x18},
	{0x1347, 0x00},
	{0x1348, 0x8c},
	{0x1349, 0x65},
	{0x134a, 0x00},
	{0x134b, 0x00},
	{0x134c, 0x03},
	{0x134d, 0xff},
	{0x134e, 0xff},
	{0x134f, 0x84},
	{0x1350, 0xa8},
	{0x1351, 0x63},
	{0x1352, 0x00},
	{0x1353, 0x10},
	{0x1354, 0x10},
	{0x1355, 0x00},
	{0x1356, 0x00},
	{0x1357, 0x0c},
	{0x1358, 0x15},
	{0x1359, 0x00},
	{0x135a, 0x00},
	{0x135b, 0x00},
	{0x135c, 0x18},
	{0x135d, 0x60},
	{0x135e, 0x00},
	{0x135f, 0x14},
	{0x1360, 0xa8},
	{0x1361, 0x63},
	{0x1362, 0x10},
	{0x1363, 0x30},
	{0x1364, 0x8c},
	{0x1365, 0x83},
	{0x1366, 0x00},
	{0x1367, 0x00},
	{0x1368, 0x18},
	{0x1369, 0x60},
	{0x136a, 0x00},
	{0x136b, 0x14},
	{0x136c, 0xa8},
	{0x136d, 0x63},
	{0x136e, 0x10},
	{0x136f, 0x31},
	{0x1370, 0x03},
	{0x1371, 0xff},
	{0x1372, 0xff},
	{0x1373, 0x95},
	{0x1374, 0x15},
	{0x1375, 0x00},
	{0x1376, 0x00},
	{0x1377, 0x00},
	{0x1378, 0xb8},
	{0x1379, 0x83},
	{0x137a, 0x00},
	{0x137b, 0x44},
	{0x137c, 0x03},
	{0x137d, 0xff},
	{0x137e, 0xff},
	{0x137f, 0x3b},
	{0x1380, 0x9c},
	{0x1381, 0x84},
	{0x1382, 0x00},
	{0x1383, 0x30},
	{0x1384, 0x18},
	{0x1385, 0x60},
	{0x1386, 0x00},
	{0x1387, 0x14},
	{0x1388, 0xa8},
	{0x1389, 0x63},
	{0x138a, 0x10},
	{0x138b, 0x32},
	{0x138c, 0x8c},
	{0x138d, 0x83},
	{0x138e, 0x00},
	{0x138f, 0x00},
	{0x1390, 0x18},
	{0x1391, 0x60},
	{0x1392, 0x00},
	{0x1393, 0x14},
	{0x1394, 0xa8},
	{0x1395, 0x63},
	{0x1396, 0x10},
	{0x1397, 0x33},
	{0x1398, 0x03},
	{0x1399, 0xff},
	{0x139a, 0xff},
	{0x139b, 0x8b},
	{0x139c, 0x15},
	{0x139d, 0x00},
	{0x139e, 0x00},
	{0x139f, 0x00},
	{0x13a0, 0x85},
	{0x13a1, 0x21},
	{0x13a2, 0x00},
	{0x13a3, 0x00},
	{0x13a4, 0x85},
	{0x13a5, 0x41},
	{0x13a6, 0x00},
	{0x13a7, 0x04},
	{0x13a8, 0x44},
	{0x13a9, 0x00},
	{0x13aa, 0x48},
	{0x13ab, 0x00},
	{0x13ac, 0x9c},
	{0x13ad, 0x21},
	{0x13ae, 0x00},
	{0x13af, 0x08},
	{0x13b0, 0x9c},
	{0x13b1, 0x21},
	{0x13b2, 0xff},
	{0x13b3, 0xec},
	{0x13b4, 0xd4},
	{0x13b5, 0x01},
	{0x13b6, 0x48},
	{0x13b7, 0x0c},
	{0x13b8, 0xd4},
	{0x13b9, 0x01},
	{0x13ba, 0x50},
	{0x13bb, 0x10},
	{0x13bc, 0x18},
	{0x13bd, 0x60},
	{0x13be, 0x00},
	{0x13bf, 0x14},
	{0x13c0, 0xa8},
	{0x13c1, 0x63},
	{0x13c2, 0x10},
	{0x13c3, 0x00},
	{0x13c4, 0x19},
	{0x13c5, 0x40},
	{0x13c6, 0x00},
	{0x13c7, 0x14},
	{0x13c8, 0xa9},
	{0x13c9, 0x4a},
	{0x13ca, 0x00},
	{0x13cb, 0x18},
	{0x13cc, 0xd4},
	{0x13cd, 0x01},
	{0x13ce, 0x18},
	{0x13cf, 0x00},
	{0x13d0, 0x84},
	{0x13d1, 0x8a},
	{0x13d2, 0x00},
	{0x13d3, 0x00},
	{0x13d4, 0x8c},
	{0x13d5, 0x64},
	{0x13d6, 0x00},
	{0x13d7, 0x1c},
	{0x13d8, 0xd4},
	{0x13d9, 0x01},
	{0x13da, 0x18},
	{0x13db, 0x04},
	{0x13dc, 0x8c},
	{0x13dd, 0x64},
	{0x13de, 0x00},
	{0x13df, 0x1d},
	{0x13e0, 0x07},
	{0x13e1, 0xfb},
	{0x13e2, 0x1f},
	{0x13e3, 0xb1},
	{0x13e4, 0xd4},
	{0x13e5, 0x01},
	{0x13e6, 0x18},
	{0x13e7, 0x08},
	{0x13e8, 0x18},
	{0x13e9, 0x60},
	{0x13ea, 0x80},
	{0x13eb, 0x80},
	{0x13ec, 0xa8},
	{0x13ed, 0x83},
	{0x13ee, 0x01},
	{0x13ef, 0x00},
	{0x13f0, 0xa9},
	{0x13f1, 0x03},
	{0x13f2, 0x01},
	{0x13f3, 0x02},
	{0x13f4, 0x8c},
	{0x13f5, 0x84},
	{0x13f6, 0x00},
	{0x13f7, 0x00},
	{0x13f8, 0xa9},
	{0x13f9, 0x63},
	{0x13fa, 0x01},
	{0x13fb, 0x03},
	{0x13fc, 0xa8},
	{0x13fd, 0xa3},
	{0x13fe, 0x01},
	{0x13ff, 0x01},
	{0x1400, 0xbc},
	{0x1401, 0x04},
	{0x1402, 0x00},
	{0x1403, 0x00},
	{0x1404, 0x8c},
	{0x1405, 0x65},
	{0x1406, 0x00},
	{0x1407, 0x00},
	{0x1408, 0x8c},
	{0x1409, 0x88},
	{0x140a, 0x00},
	{0x140b, 0x00},
	{0x140c, 0xa8},
	{0x140d, 0xc3},
	{0x140e, 0x00},
	{0x140f, 0x00},
	{0x1410, 0x8c},
	{0x1411, 0x6b},
	{0x1412, 0x00},
	{0x1413, 0x00},
	{0x1414, 0x10},
	{0x1415, 0x00},
	{0x1416, 0x00},
	{0x1417, 0x06},
	{0x1418, 0xa8},
	{0x1419, 0xe3},
	{0x141a, 0x00},
	{0x141b, 0x00},
	{0x141c, 0x84},
	{0x141d, 0xaa},
	{0x141e, 0x00},
	{0x141f, 0x00},
	{0x1420, 0x8c},
	{0x1421, 0x65},
	{0x1422, 0x00},
	{0x1423, 0x52},
	{0x1424, 0xd8},
	{0x1425, 0x05},
	{0x1426, 0x20},
	{0x1427, 0x52},
	{0x1428, 0xd8},
	{0x1429, 0x08},
	{0x142a, 0x18},
	{0x142b, 0x00},
	{0x142c, 0xbc},
	{0x142d, 0x06},
	{0x142e, 0x00},
	{0x142f, 0x00},
	{0x1430, 0x10},
	{0x1431, 0x00},
	{0x1432, 0x00},
	{0x1433, 0x06},
	{0x1434, 0x15},
	{0x1435, 0x00},
	{0x1436, 0x00},
	{0x1437, 0x00},
	{0x1438, 0x84},
	{0x1439, 0x8a},
	{0x143a, 0x00},
	{0x143b, 0x00},
	{0x143c, 0x8c},
	{0x143d, 0x64},
	{0x143e, 0x00},
	{0x143f, 0x51},
	{0x1440, 0xd8},
	{0x1441, 0x04},
	{0x1442, 0x38},
	{0x1443, 0x51},
	{0x1444, 0xd8},
	{0x1445, 0x0b},
	{0x1446, 0x18},
	{0x1447, 0x00},
	{0x1448, 0x85},
	{0x1449, 0x21},
	{0x144a, 0x00},
	{0x144b, 0x0c},
	{0x144c, 0x85},
	{0x144d, 0x41},
	{0x144e, 0x00},
	{0x144f, 0x10},
	{0x1450, 0x44},
	{0x1451, 0x00},
	{0x1452, 0x48},
	{0x1453, 0x00},
	{0x1454, 0x9c},
	{0x1455, 0x21},
	{0x1456, 0x00},
	{0x1457, 0x14},

	{0xfffe, 0x14},
	{0x1ff4, 0x00},
	{0x1ff5, 0x00},
	{0x1ff6, 0x00},
	{0x1ff7, 0x20},
	{0x1f98, 0x00},
	{0x1f99, 0x14},
	{0x1f9a, 0x10},
	{0x1f9b, 0x34},
	{0xfffe, 0x80},
	{0x000e, 0x54},

	{0xfffe, 0x14},
	{0x1f04, 0x7f},
	{0x1f05, 0xff},
	{0x1f06, 0xff},
	{0x1f07, 0xff},
	{0x1f08, 0x7f},
	{0x1f09, 0xff},
	{0x1f0a, 0xff},
	{0x1f0b, 0xff},
	{0x1f0c, 0x7f},
	{0x1f0d, 0xff},
	{0x1f0e, 0xff},
	{0x1f0e, 0xff},
	{0x1f10, 0x7f},
	{0x1f11, 0xff},
	{0x1f12, 0xff},
	{0x1f13, 0xff},
	{0x1f14, 0x7f},
	{0x1f15, 0xff},
	{0x1f16, 0xff},
	{0x1f17, 0xff},
	{0x1f18, 0x00},
	{0x1f19, 0x14},
	{0x1f1a, 0x13},
	{0x1f1b, 0xb0},

	{0x1ff0, 0x00},
	{0x1ff1, 0x00},
	{0x1ff2, 0x00},
	{0x1ff3, 0x20},

	{0xfffe, 0x80},
	{0x0100, 0x01},
	{0x0101, 0x00},
	{0x000f, 0x54},

	{0xfffe, 0x80},
	{0x012c, 0x00},

	{0xfffe, 0x14},
	{0x0002, 0x01},
	{0x0020, 0x01},
	{0x0021, 0x00},
	{0x0022, 0x01},
	{0x0088, 0x10},
	{0x0089, 0x10},
	{0x008a, 0x10},
	{0x008c, 0x08},
	{0x003d, 0x70},
	{0x0036, 0x00},
	{0x0037, 0x28},
	{0x003f, 0x00},
	{0x003e, 0x60},
	{0x0070, 0x02},

	{0x0040, 0x00},
	{0x0041, 0x02},
	{0x0042, 0x00},
	{0x0043, 0x01},
	{0x0044, 0x00},
	{0x0045, 0x00},
	{0x0046, 0x00},
	{0x0047, 0x00},
	{0x0048, 0x00},
	{0x0049, 0xff},
	{0x004a, 0x00},
	{0x004b, 0xff},
	{0x004c, 0x00},
	{0x004d, 0x00},
	{0x004e, 0x00},
	{0x004f, 0x00},
	{0x0050, 0x00},
	{0x0051, 0x00},
	{0x0052, 0x00},
	{0x0053, 0x00},
	{0x0054, 0x00},
	{0x0055, 0x00},
	{0x0056, 0x00},
	{0x0057, 0x00},
	{0x0058, 0x00},
	{0x0059, 0x00},
	{0x005a, 0x00},
	{0x005b, 0x00},
	{0x005c, 0x00},
	{0x005d, 0x00},
	{0x005e, 0x00},
	{0x005f, 0x00},
	{0x0060, 0x00},
	{0x0061, 0x00},
	{0x0062, 0x00},
	{0x0063, 0x0a},
	{0x0064, 0x00},
	{0x0065, 0x00},
	{0x0066, 0x00},
	{0x0067, 0x00},
	{0x0068, 0x00},
	{0x0069, 0xff},
	{0x006a, 0x00},
	{0x006b, 0xff},
	{0x006c, 0x00},
	{0x006d, 0x00},
	{0x006e, 0x00},
	{0x006f, 0x00},
	{0x007a, 0x02},
	{0x007b, 0xd0},
	{0x007c, 0x00},
	{0x008e, 0x3f},
	{0x008f, 0x00},
	{0x0094, 0x0e},
	{0x0095, 0x10},

	{0xfffd, 0x80},
	{0xfffe, 0x21},
	{0x0680, 0x00},
	{0x0681, 0x00},
	{0x0682, 0x00},
	{0x0683, 0x00},
	{0x0684, 0x02},
	{0x0685, 0x00},
	{0x0686, 0x01},
	{0x0687, 0xd0},
	{0x0688, 0x11},
	{0x0689, 0x11},
	{0x068a, 0x11},
	{0x068b, 0x11},
	{0x068c, 0x11},
	{0x068d, 0x11},
	{0x068e, 0x11},
	{0x068f, 0x11},
	{0x0690, 0x03},

	{0xfffe, 0x21},
	{0x0800, 0xd},
	{0x0801, 0x8},
	{0x0802, 0x7},
	{0x0803, 0x7},
	{0x0804, 0x8},
	{0x0805, 0xc},
	{0x0806, 0x4},
	{0x0807, 0x1},
	{0x0808, 0x1},
	{0x0809, 0x1},
	{0x080a, 0x1},
	{0x080b, 0x4},
	{0x080c, 0x1},
	{0x080d, 0x0},
	{0x080e, 0x0},
	{0x080f, 0x0},
	{0x0810, 0x0},
	{0x0811, 0x2},
	{0x0812, 0x2},
	{0x0813, 0x0},
	{0x0814, 0x0},
	{0x0815, 0x0},
	{0x0816, 0x0},
	{0x0817, 0x2},
	{0x0818, 0x4},
	{0x0819, 0x2},
	{0x081a, 0x1},
	{0x081b, 0x1},
	{0x081c, 0x2},
	{0x081d, 0x5},
	{0x081e, 0x15},
	{0x081f, 0xc},
	{0x0820, 0xb},
	{0x0821, 0xa},
	{0x0822, 0xd},
	{0x0823, 0x17},
	{0x0824, 0x20},
	{0x0825, 0x22},
	{0x0826, 0x20},
	{0x0827, 0x22},
	{0x0828, 0x2},
	{0x082a, 0x20},
	{0x082b, 0x22},
	{0x082c, 0x42},
	{0x082d, 0x42},
	{0x082e, 0x0},
	{0x0830, 0x20},
	{0x0831, 0x42},
	{0x0832, 0x42},
	{0x0833, 0x42},
	{0x0834, 0x0},
	{0x0836, 0x20},
	{0x0837, 0x42},
	{0x0838, 0x42},
	{0x0839, 0x42},
	{0x083a, 0x0},
	{0x083c, 0x22},
	{0x083d, 0x2},
	{0x083e, 0x22},
	{0x083f, 0x22},
	{0x0840, 0x2},
	{0x0848, 0xce},

	{0x084a, 0x88},
	{0x084d, 0x02},
	{0x084e, 0x66},
	{0x084f, 0x04},
	{0x0850, 0x44},
	{0x0851, 0x03},
	{0x0852, 0x33},
	{0x0853, 0x02},
	{0x0854, 0xD8},

	{0xfffe, 0x14},
	{0x02b3, 0x01},
	{0x02b6, 0x06},
	{0x02b7, 0x00},
	{0x02ba, 0x04},
	{0x02bb, 0x00},
	{0x02be, 0x04},
	{0x02bf, 0x00},
	{0x02c2, 0x04},
	{0x02c3, 0x04},
	{0x030a, 0x05},
	{0x030b, 0x00},
	{0x030c, 0x04},
	{0x030d, 0x00},
	{0x030e, 0x05},
	{0x030f, 0xa0},

	{0xfffe, 0x14},
	{0x0000, 0x01},
	{0x02b0, 0x00},
	{0x02b2, 0x01},
	{0x02d4, 0x00},
	{0x02d5, 0xf0},
	{0x02d6, 0x0d},
	{0x02d7, 0xff},
	{0xfffe, 0x21},
	{0x0000, 0x47},
	{0x0091, 0xb0},
	{0x0092, 0x0c},
	{0x0001, 0x82},
	{0x0003, 0xb1},
	{0x0051, 0x03},
	{0x0096, 0x83},
	{0x019c, 0x0a},
	{0x0019, 0x48},

	{0x01b0, 0x7f},
	{0x01b1, 0xb8},
	{0x01b2, 0x3f},
	{0x01b3, 0x5b},
	{0x01b4, 0x67},
	{0x01b5, 0x9d},
	{0x01b6, 0x4e},
	{0x01b7, 0x7c},
	{0x01b8, 0x50},
	{0x01b9, 0x74},
	{0x01ba, 0x62},
	{0x01bb, 0x9e},
	{0x01bc, 0x72},
	{0x01bd, 0x96},
	{0x01be, 0x78},
	{0x01bf, 0x90},
	{0x01c0, 0x00},
	{0x01c1, 0x00},
	{0x01c2, 0x00},
	{0x01c3, 0x00},
	{0x01c4, 0x00},
	{0x01c5, 0x00},
	{0x01c6, 0x00},
	{0x01c7, 0x00},
	{0x01c8, 0x00},
	{0x01c9, 0x00},
	{0x01ca, 0x00},
	{0x01cb, 0x00},
	{0x01cc, 0x00},
	{0x01cd, 0x00},
	{0x01ce, 0x00},
	{0x01cf, 0x00},
	{0x01d0, 0x00},
	{0x01d1, 0x00},
	{0x01d2, 0x00},
	{0x01d3, 0x00},
	{0x01d4, 0x00},
	{0x01d5, 0x00},
	{0x01d6, 0x00},
	{0x01d7, 0x00},
	{0x01d8, 0x00},
	{0x01d9, 0x00},
	{0x01da, 0x00},
	{0x01db, 0x00},
	{0x01dc, 0x00},
	{0x01dd, 0x00},
	{0x01de, 0x00},
	{0x01df, 0x00},
	{0x01e0, 0x00},
	{0x01e1, 0x00},
	{0x01e2, 0x00},
	{0x01e3, 0x00},
	{0x01e4, 0x00},
	{0x01e5, 0x00},
	{0x01e6, 0x00},
	{0x01e7, 0x00},
	{0x01e8, 0x00},
	{0x01e9, 0x00},
	{0x01ea, 0x00},
	{0x01eb, 0x00},
	{0x01ec, 0x00},
	{0x01ed, 0x00},
	{0x01ee, 0x00},
	{0x01ef, 0x00},
	{0x01f0, 0x22},
	{0x01f1, 0x21},
	{0x01f2, 0x00},
	{0x01f3, 0x00},
	{0x01f4, 0x00},
	{0x01f5, 0x00},
	{0x01f6, 0x00},
	{0x01f7, 0x00},

	{0xfffe, 0x14},
	{0x02b3, 0x00},
	{0xfffd, 0x80},
	{0xfffe, 0x21},
	{0x0480, 0xc},
	{0x0481, 0x18},
	{0x0482, 0x30},
	{0x0483, 0x5d},
	{0x0484, 0x72},
	{0x0485, 0x84},
	{0x0486, 0x95},
	{0x0487, 0xa3},
	{0x0488, 0xaf},
	{0x0489, 0xb9},
	{0x048a, 0xc8},
	{0x048b, 0xd1},
	{0x048c, 0xdc},
	{0x048d, 0xe5},
	{0x048e, 0xef},
	{0x048f, 0xB},

	{0xFFFD, 0x80},
	{0xFFFE, 0x21},
	{0xd00, 0x1},
	{0xD01, 0xB6},
	{0xD02, 0x2},
	{0xD03, 0x16},
	{0xD04, 0x0},
	{0xD05, 0xAA},
	{0xD06, 0x0},
	{0xD07, 0x97},
	{0xD08, 0x0},
	{0xD09, 0x5A},
	{0xD0A, 0x0},
	{0xD0B, 0x6F},
	{0xD0C, 0x2},
	{0xD0D, 0x47},
	{0xD0E, 0x2},
	{0xD0F, 0xDF},
	{0xD10, 0x1},
	{0xD11, 0x24},
	{0xD12, 0x1},
	{0xD13, 0x3B},
	{0xD14, 0x0},
	{0xD15, 0xB1},
	{0xD16, 0x0},
	{0xD17, 0xF},
	{0xD18, 0x2},
	{0xD19, 0x47},
	{0xD1A, 0x2},
	{0xD1B, 0xDF},
	{0xD1C, 0x1},
	{0xD1D, 0x24},
	{0xD1E, 0x1},
	{0xD1F, 0x3B},
	{0xD20, 0x0},
	{0xD21, 0xB1},
	{0xD22, 0x0},
	{0xD23, 0xF},
	{0xd2e, 0x6},
	{0xD2F, 0x8},
	{0xD30, 0x8},
	{0xD31, 0x03},
	{0xd28, 0x0},
	{0xD29, 0x69},
	{0xD2A, 0x0},
	{0xD2B, 0xB6},
	{0xD2C, 0x1},
	{0xD2D, 0x1A},

	{0xfffe, 0x21},
	{0x0005, 0x90},
	{0x0013, 0x08},
	{0x0402, 0x10},
	{0x0403, 0x14},
	{0x0580, 0x08},
	{0x0581, 0x42},
	{0x0582, 0x44},

	{0xfffd, 0x80},
	{0xfffe, 0x21},
	{0x0290, 0x06},
	{0x0291, 0x08},
	{0x0292, 0x00},
	{0x029a, 0x00},
	{0x029b, 0x02},
	{0x029c, 0x04},
	{0x029d, 0x06},
	{0x029e, 0x08},
	{0x029f, 0x09},
	{0x02a0, 0x0a},

	{0xfffd, 0x80},
	{0xfffe, 0x21},
	{0x0301, 0x10},
	{0x0303, 0x6f},
	{0x0304, 0x00},
	{0x0305, 0x10},
	{0x0306, 0x00},
	{0x0307, 0x00},
	{0x0308, 0x30},
	{0x0309, 0x00},
	{0x030a, 0x03},
	{0x030b, 0x02},
	{0x030c, 0x04},
	{0x030d, 0x18},
	{0x030e, 0x18},
	{0x030f, 0xc0},
	{0x0310, 0x20},
	{0x0311, 0xff},
	{0x0312, 0x80},
	{0x0313, 0x18},
	{0x0314, 0x08},
	{0x0315, 0x3f},
	{0x0317, 0x06},
	{0x0318, 0x00},
	{0x0319, 0x1f},

	{0x031a, 0x00},
	{0x031b, 0x00},
	{0x031c, 0x00},
	{0x031d, 0x00},
	{0x031e, 0x08},
	{0x031f, 0x08},
	{0x0320, 0x80},
	{0x0321, 0x20},

	{0xfffe, 0x14},
	{0xfffe, 0x21},
	{0x0001, 0x82},
	{0x0003, 0xb1},
	{0x031a, 0x00},
	{0x031b, 0x00},
	{0x031c, 0x00},
	{0x031d, 0x00},
	{0x031e, 0x10},
	{0x031f, 0x0c},

	{0x0320, 0x0a},
	{0x0321, 0x0f},
	{0x0580, 0x08},
	{0x0581, 0x60},
	{0x0582, 0x60},
	{0x0584, 0x20},

	{0xfffe, 0x80},
	{0x0137, 0x66},

	{0xfffe, 0x21},
	{0x006c, 0x20},
};

#if defined(FIXED_FRAME_RATE)

static struct regval_list sensor_720P_regs[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x80},
	{0x00bc, 0x91},
	{0x001b, 0x0},
	{0x0090, 0x28},
	{0x0038, 0x01},
	{0xfffe, 0x26},
	{0x0000, 0x00},
	{0x0002, 0x0},
	{0x0009, 0x4},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0xA},
	{0x6007, 0x8C},
	{0x6008, 0x9},
	{0x6009, 0xFC},
	{0x8000, 0x3f},
	{0x8001, 0x0},
	{0x8002, 0x5},
	{0x8003, 0xD0},
	{0x8004, 0x2},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8010, 0x4},
	{0x2019, 0x5},
	{0x201a, 0x0},
	{0x201b, 0x2},
	{0x201c, 0xD0},
	{0x201d, 0x0},
	{0x201e, 0x0},
	{0x201f, 0x0},
	{0x2020, 0x0},
	{0x2015, 0x80},
	{0x2017, 0x1e},
	{0x2018, 0x1e},
	{0x2023, 0x3},
	{0x8012, 0x0},
	{0x8013, 0x5},
	{0x8014, 0xD0},
	{0x8015, 0x2},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},
	{0xfffe, 0x21},
	{0x0001, 0x82},
	{0x0004, 0x10},
	{0x0708, 0x0},
	{0x0072, 0x0},
	{0x0074, 0x0},
	{0x0006, 0x5},
	{0x0007, 0x0},
	{0x0008, 0x2},
	{0x0009, 0xD0},
	{0x000a, 0x5},
	{0x000b, 0x0},
	{0x000c, 0x2},
	{0x000d, 0xD0},
	{0x001e, 0x5},
	{0x001f, 0x0},
	{0x0020, 0x2},
	{0x0021, 0xD0},
	{0x005e, 0xFF},
	{0x005f, 0x4},
	{0x0060, 0xCF},
	{0x0061, 0x2},
	{0x0064, 0x0},
	{0x0065, 0x5},
	{0x0066, 0xD0},
	{0x0067, 0x2},
	{0x0076, 0x5},
	{0x0077, 0x0},
	{0x0078, 0x2},
	{0x0079, 0xD0},
	{0x0700, 0x0},
	{0x0701, 0x0},
	{0x0702, 0x0},
	{0x0703, 0x0},
	{0x0704, 0x5},
	{0x0705, 0x0},
	{0x0706, 0x2},
	{0x0707, 0xD0},

	{0xfffd, 0x80},
	{0xfffe, 0x21},
	{0x0680, 0x00},
	{0x0681, 0x00},
	{0x0682, 0x00},
	{0x0683, 0x00},
	{0x0684, 0x05},
	{0x0685, 0x00},
	{0x0686, 0x02},
	{0x0687, 0xd0},
	{0x0688, 0x11},
	{0x0689, 0x11},
	{0x068a, 0x11},
	{0x068b, 0x11},
	{0x068c, 0x11},
	{0x068d, 0x11},
	{0x068e, 0x11},
	{0x068f, 0x11},
	{0x0690, 0x03},

};
#else

static struct regval_list sensor_720P_regs[] = {
};
#endif

static struct regval_list sensor_wb_manual[] = {
};

static struct regval_list sensor_wb_auto_regs[] = {
	0xfffe, 0x14,
	0x0000, 0x01,
};

static struct regval_list sensor_wb_incandescence_regs[] = {

};

static struct regval_list sensor_wb_fluorescent_regs[] = {
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x0000, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x21,
	0x0098, 0x05,
	0x0099, 0x80,
	0x009a, 0x04,
	0x009b, 0x00,
	0x009c, 0x04,
};

static struct regval_list sensor_wb_tungsten_regs[] = {
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x0000, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x21,
	0x0098, 0x04,
	0x0099, 0x10,
	0x009a, 0x04,
	0x009b, 0x00,
	0x009c, 0x07,
	0x009d, 0x10,
};

static struct regval_list sensor_wb_horizon[] = {
};

static struct regval_list sensor_wb_daylight_regs[] = {
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x0000, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x21,
	0x0098, 0x06,
	0x0099, 0x10,
	0x009a, 0x04,
	0x009b, 0x00,
	0x009c, 0x04,
	0x009d, 0x48,
};

static struct regval_list sensor_wb_flash[] = {
};

static struct regval_list sensor_wb_cloud_regs[] = {
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x0000, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x21,
	0x0098, 0x06,
	0x0099, 0xff,
	0x009a, 0x04,
	0x009b, 0x00,
	0x009c, 0x04,
	0x009d, 0x30,
};

static struct regval_list sensor_wb_shade[] = {
};

static struct cfg_array sensor_wb[] = {
	{
	 .regs = sensor_wb_manual,
	 .size = ARRAY_SIZE(sensor_wb_manual),
	 },
	{
	 .regs = sensor_wb_auto_regs,
	 .size = ARRAY_SIZE(sensor_wb_auto_regs),
	 },
	{
	 .regs = sensor_wb_incandescence_regs,
	 .size = ARRAY_SIZE(sensor_wb_incandescence_regs),
	 },
	{
	 .regs = sensor_wb_fluorescent_regs,
	 .size = ARRAY_SIZE(sensor_wb_fluorescent_regs),
	 },
	{
	 .regs = sensor_wb_tungsten_regs,
	 .size = ARRAY_SIZE(sensor_wb_tungsten_regs),
	 },
	{
	 .regs = sensor_wb_horizon,
	 .size = ARRAY_SIZE(sensor_wb_horizon),
	 },
	{
	 .regs = sensor_wb_daylight_regs,
	 .size = ARRAY_SIZE(sensor_wb_daylight_regs),
	 },
	{
	 .regs = sensor_wb_flash,
	 .size = ARRAY_SIZE(sensor_wb_flash),
	 },
	{
	 .regs = sensor_wb_cloud_regs,
	 .size = ARRAY_SIZE(sensor_wb_cloud_regs),
	 },
	{
	 .regs = sensor_wb_shade,
	 .size = ARRAY_SIZE(sensor_wb_shade),
	 },
};

static struct regval_list sensor_colorfx_none_regs[] = {

};

static struct regval_list sensor_colorfx_bw_regs[] = {

};

static struct regval_list sensor_colorfx_sepia_regs[] = {

};

static struct regval_list sensor_colorfx_negative_regs[] = {

};

static struct regval_list sensor_colorfx_sky_blue_regs[] = {

};

static struct regval_list sensor_colorfx_grass_green_regs[] = {
};

static struct regval_list sensor_colorfx_emboss_regs[] = {
};

static struct regval_list sensor_colorfx_sketch_regs[] = {
};

static struct cfg_array sensor_colorfx[] = {
	{
	 .regs = sensor_colorfx_none_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_none_regs),
	 },
	{
	 .regs = sensor_colorfx_bw_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_bw_regs),
	 },
	{
	 .regs = sensor_colorfx_sepia_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_sepia_regs),
	 },
	{
	 .regs = sensor_colorfx_negative_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_negative_regs),
	 },
	{
	 .regs = sensor_colorfx_emboss_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_negative_regs),
	 },
	{
	 .regs = sensor_colorfx_sketch_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_sketch_regs),
	 },
	{
	 .regs = sensor_colorfx_sky_blue_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_sky_blue_regs),
	 },
	{
	 .regs = sensor_colorfx_grass_green_regs,
	 .size = ARRAY_SIZE(sensor_colorfx_grass_green_regs),
	 },
};

static struct regval_list sensor_qvga_regs[] = {
};


static struct regval_list sensor_xga_regs[] = {

};

#if defined(FIXED_FRAME_RATE)

static struct regval_list sensor_vga_regs[] = {
	{0xfffd, 0x80},
	{0xfffe, 0x80},
	{0x00bc, 0x91},
	{0x001b, 0x0},
	{0x0090, 0x28},
	{0x0038, 0x01},
	{0xfffe, 0x26},
	{0x0000, 0x00},
	{0x0002, 0x0},
	{0x0009, 0x4},
	{0x4000, 0xF9},
	{0x6001, 0x14},
	{0x6005, 0xc4},
	{0x6006, 0x5},
	{0x6007, 0x78},
	{0x6008, 0x4},
	{0x6009, 0xFC},
	{0x8000, 0x3f},
	{0x8001, 0x0},
	{0x8002, 0x5},
	{0x8003, 0xD0},
	{0x8004, 0x2},
	{0x8005, 0x3},
	{0x8006, 0x5},
	{0x8007, 0x99},
	{0x8010, 0x5},
	{0x2019, 0x2},
	{0x201a, 0x80},
	{0x201b, 0x1},
	{0x201c, 0xE0},
	{0x201d, 0x0},
	{0x201e, 0x0},
	{0x201f, 0x0},
	{0x2020, 0x0},
	{0x2015, 0x80},
	{0x2017, 0x1e},
	{0x2018, 0x1e},
	{0x2023, 0x03},
	{0x8012, 0x80},
	{0x8013, 0x2},
	{0x8014, 0xE0},
	{0x8015, 0x1},
	{0x8016, 0x0},
	{0x8017, 0x0},
	{0x8018, 0x0},
	{0x8019, 0x0},
	{0xfffe, 0x21},
	{0x0001, 0x82},
	{0x0004, 0x10},
	{0x0708, 0x0},
	{0x0072, 0x0},
	{0x0074, 0x0},
	{0x0006, 0x2},
	{0x0007, 0x80},
	{0x0008, 0x1},
	{0x0009, 0xE0},
	{0x000a, 0x2},
	{0x000b, 0x80},
	{0x000c, 0x1},
	{0x000d, 0xE0},
	{0x001e, 0x2},
	{0x001f, 0x80},
	{0x0020, 0x1},
	{0x0021, 0xE0},
	{0x005e, 0x7F},
	{0x005f, 0x2},
	{0x0060, 0xDF},
	{0x0061, 0x1},
	{0x0064, 0x80},
	{0x0065, 0x2},
	{0x0066, 0xE0},
	{0x0067, 0x1},
	{0x0076, 0x2},
	{0x0077, 0x80},
	{0x0078, 0x1},
	{0x0079, 0xE0},
	{0x0700, 0x0},
	{0x0701, 0x0},
	{0x0702, 0x0},
	{0x0703, 0x0},
	{0x0704, 0x2},
	{0x0705, 0x80},
	{0x0706, 0x1},
	{0x0707, 0xE0},

	{0xfffe, 0x80},
	{0x0137, 0x66},

	{0xfffd, 0x80},
	{0xfffe, 0x21},
	{0x0680, 0x00},
	{0x0681, 0x00},
	{0x0682, 0x00},
	{0x0683, 0x00},
	{0x0684, 0x02},
	{0x0685, 0x00},
	{0x0686, 0x01},
	{0x0687, 0xd0},
	{0x0688, 0x11},
	{0x0689, 0x11},
	{0x068a, 0x11},
	{0x068b, 0x11},
	{0x068c, 0x11},
	{0x068d, 0x11},
	{0x068e, 0x11},
	{0x068f, 0x11},
	{0x0690, 0x03},
};
#else

static struct regval_list sensor_vga_regs[] = {

};
#endif

static struct regval_list sensor_uxga_regs[] = {
};

static struct regval_list sensor_svga_regs[] = {
};

static struct regval_list sensor_1080P_regs[] = {
};

static struct cfg_array sensor_resolution[] = {
	{
	 .regs = sensor_1080P_regs,	/* 1280X1080 1080P */
	 .size = ARRAY_SIZE(sensor_1080P_regs),
	 },
	{
	 .regs = sensor_uxga_regs,	/* 1600X1200 UXGA */
	 .size = ARRAY_SIZE(sensor_720P_regs),
	 },
	{
	 .regs = sensor_720P_regs,	/* 1280X720 720P */
	 .size = ARRAY_SIZE(sensor_720P_regs),
	 },
	{
	 .regs = sensor_xga_regs,	/* 1024x576 XGA */
	 .size = ARRAY_SIZE(sensor_xga_regs),
	 },
	{
	 .regs = sensor_svga_regs,	/* 800x600 SVGA */
	 .size = ARRAY_SIZE(sensor_svga_regs),
	 },
	{
	 .regs = sensor_vga_regs,	/* 640X480 VGA */
	 .size = ARRAY_SIZE(sensor_vga_regs),
	 },
	{
	 .regs = sensor_qvga_regs,	/* 320X240 VGA */
	 .size = ARRAY_SIZE(sensor_qvga_regs),
	 },
};

static struct regval_list sensor_brightness_neg4_regs[] = {

};

static struct regval_list sensor_brightness_neg3_regs[] = {

};

static struct regval_list sensor_brightness_neg2_regs[] = {

};

static struct regval_list sensor_brightness_neg1_regs[] = {

};

static struct regval_list sensor_brightness_zero_regs[] = {

};

static struct regval_list sensor_brightness_pos1_regs[] = {

};

static struct regval_list sensor_brightness_pos2_regs[] = {

};

static struct regval_list sensor_brightness_pos3_regs[] = {

};

static struct regval_list sensor_brightness_pos4_regs[] = {

};

static struct cfg_array sensor_brightness[] = {
	{
	 .regs = sensor_brightness_neg4_regs,
	 .size = ARRAY_SIZE(sensor_brightness_neg4_regs),
	 },
	{
	 .regs = sensor_brightness_neg3_regs,
	 .size = ARRAY_SIZE(sensor_brightness_neg3_regs),
	 },
	{
	 .regs = sensor_brightness_neg2_regs,
	 .size = ARRAY_SIZE(sensor_brightness_neg2_regs),
	 },
	{
	 .regs = sensor_brightness_neg1_regs,
	 .size = ARRAY_SIZE(sensor_brightness_neg1_regs),
	 },
	{
	 .regs = sensor_brightness_zero_regs,
	 .size = ARRAY_SIZE(sensor_brightness_zero_regs),
	 },
	{
	 .regs = sensor_brightness_pos1_regs,
	 .size = ARRAY_SIZE(sensor_brightness_pos1_regs),
	 },
	{
	 .regs = sensor_brightness_pos2_regs,
	 .size = ARRAY_SIZE(sensor_brightness_pos2_regs),
	 },
	{
	 .regs = sensor_brightness_pos3_regs,
	 .size = ARRAY_SIZE(sensor_brightness_pos3_regs),
	 },
	{
	 .regs = sensor_brightness_pos4_regs,
	 .size = ARRAY_SIZE(sensor_brightness_pos4_regs),
	 },
};

static struct regval_list sensor_saturation_neg4_regs[] = {

};

static struct regval_list sensor_saturation_neg3_regs[] = {

};

static struct regval_list sensor_saturation_neg2_regs[] = {

};

static struct regval_list sensor_saturation_neg1_regs[] = {

};

static struct regval_list sensor_saturation_zero_regs[] = {

};

static struct regval_list sensor_saturation_pos1_regs[] = {

};

static struct regval_list sensor_saturation_pos2_regs[] = {

};

static struct regval_list sensor_saturation_pos3_regs[] = {

};

static struct regval_list sensor_saturation_pos4_regs[] = {

};

static struct cfg_array sensor_saturation[] = {
	{
	 .regs = sensor_saturation_neg4_regs,
	 .size = ARRAY_SIZE(sensor_saturation_neg4_regs),
	 },
	{
	 .regs = sensor_saturation_neg3_regs,
	 .size = ARRAY_SIZE(sensor_saturation_neg3_regs),
	 },
	{
	 .regs = sensor_saturation_neg2_regs,
	 .size = ARRAY_SIZE(sensor_saturation_neg2_regs),
	 },
	{
	 .regs = sensor_saturation_neg1_regs,
	 .size = ARRAY_SIZE(sensor_saturation_neg1_regs),
	 },
	{
	 .regs = sensor_saturation_zero_regs,
	 .size = ARRAY_SIZE(sensor_saturation_zero_regs),
	 },
	{
	 .regs = sensor_saturation_pos1_regs,
	 .size = ARRAY_SIZE(sensor_saturation_pos1_regs),
	 },
	{
	 .regs = sensor_saturation_pos2_regs,
	 .size = ARRAY_SIZE(sensor_saturation_pos2_regs),
	 },
	{
	 .regs = sensor_saturation_pos3_regs,
	 .size = ARRAY_SIZE(sensor_saturation_pos3_regs),
	 },
	{
	 .regs = sensor_saturation_pos4_regs,
	 .size = ARRAY_SIZE(sensor_saturation_pos4_regs),
	 },
};

static struct regval_list sensor_ev_neg4_regs[] = {

};

static struct regval_list sensor_ev_neg3_regs[] = {
	0xfffe, 0x14,
	0x003d, 0x40,
};

static struct regval_list sensor_ev_neg2_regs[] = {
	0xfffe, 0x14,
	0x003d, 0x50,
};

static struct regval_list sensor_ev_neg1_regs[] = {
	0xfffe, 0x14,
	0x003d, 0x60,
};

static struct regval_list sensor_ev_zero_regs[] = {
	0xfffe, 0x14,
	0x003d, 0x68,
};

static struct regval_list sensor_ev_pos1_regs[] = {
	0xfffe, 0x14,
	0x003d, 0x80,
};

static struct regval_list sensor_ev_pos2_regs[] = {
	0xfffe, 0x14,
	0x003d, 0x90,
};

static struct regval_list sensor_ev_pos3_regs[] = {
	0xfffe, 0x14,
	0x003d, 0xa0,
};

static struct regval_list sensor_ev_pos4_regs[] = {
};

static struct cfg_array sensor_ev[] = {
	{
	 .regs = sensor_ev_neg4_regs,
	 .size = ARRAY_SIZE(sensor_ev_neg4_regs),
	 },
	{
	 .regs = sensor_ev_neg3_regs,
	 .size = ARRAY_SIZE(sensor_ev_neg3_regs),
	 },
	{
	 .regs = sensor_ev_neg2_regs,
	 .size = ARRAY_SIZE(sensor_ev_neg2_regs),
	 },
	{
	 .regs = sensor_ev_neg1_regs,
	 .size = ARRAY_SIZE(sensor_ev_neg1_regs),
	 },
	{
	 .regs = sensor_ev_zero_regs,
	 .size = ARRAY_SIZE(sensor_ev_zero_regs),
	 },
	{
	 .regs = sensor_ev_pos1_regs,
	 .size = ARRAY_SIZE(sensor_ev_pos1_regs),
	 },
	{
	 .regs = sensor_ev_pos2_regs,
	 .size = ARRAY_SIZE(sensor_ev_pos2_regs),
	 },
	{
	 .regs = sensor_ev_pos3_regs,
	 .size = ARRAY_SIZE(sensor_ev_pos3_regs),
	 },
	{
	 .regs = sensor_ev_pos4_regs,
	 .size = ARRAY_SIZE(sensor_ev_pos4_regs),
	 },
};


static struct regval_list sensor_fmt_yuv422_yuyv[] = {
	{0xfffe, 0x21},
	{0x006c, 0x20},
};

static struct regval_list sensor_fmt_yuv422_yvyu[] = {
	{0xfffe, 0x21},
	{0x006c, 0x20},
};

static struct regval_list sensor_fmt_yuv422_vyuy[] = {
	{0xfffe, 0x21},
	{0x006c, 0x20},
};

static struct regval_list sensor_fmt_yuv422_uyvy[] = {
	{0xfffe, 0x21},
	{0x006c, 0x20},
};

static struct regval_list sensor_fmt_raw[] = {
	{0x32f0, 0x50},
};

static __u16 reg_change_day_1[] = {

	0xfffe, 0x14,
	0x003d, 0x66,
	0xfffe, 0x21,
	0x0003, 0xb1,
	0x031a, 0x10,
	0x031b, 0x10,
	0x031c, 0x10,
	0x031d, 0x10,
	0x031e, 0x09,
	0x031f, 0x0c,

	0x0320, 0x0a,
	0x0321, 0x0f,
	0x0580, 0x09,
	0x0581, 0x58,
	0x0582, 0x60,
	0x0584, 0x23,
	0x0013, 0x0a,

	0xfffe, 0x14,
	0x02d4, 0x03,
	0x02d5, 0x20,
	0xfffe, 0x21,
	0x0688, 0x11,
	0x0689, 0x11,
	0x068a, 0x11,
	0x068b, 0x11,
	0x068c, 0x11,
	0x068d, 0x11,
	0x068e, 0x11,
	0x068f, 0x11,
	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0004, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x1c00, 0x01,

	0x1c01, 0x49,
	0x1c02, 0x0c,

	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0007, 0x60,
	0x000d, 0x30,
	0x0009, 0x00,
	0x00c4, 0x10,
	0x00c0, 0x01,
};

static __u16 reg_change_day_2[] = {
	0xfffe, 0x14,

	0xfffe, 0x21,
	0x0003, 0xb1,
	0x031a, 0x00,
	0x031b, 0x30,
	0x031c, 0x00,
	0x031d, 0x08,
	0x031e, 0x04,
	0x031f, 0x04,
	0x0320, 0x00,
	0x0321, 0x00,
	0x0580, 0x09,
	0x0581, 0x40,
	0x0582, 0x40,
	0x0584, 0x20,
	0x0013, 0x08,

	0xfffe, 0x14,
	0x02d4, 0x00,
	0x02d5, 0x20,
	0xfffe, 0x21,
	0x0688, 0x40,
	0x0689, 0x04,
	0x068a, 0x81,
	0x068b, 0x18,
	0x068c, 0xf8,
	0x068d, 0x8f,
	0x068e, 0x81,
	0x068f, 0x18,
	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0004, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x1c00, 0x01,

	0x1c01, 0x49,
	0x1c02, 0x10,

	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0007, 0x60,
	0x000d, 0x30,
	0x0009, 0x00,
	0x00c4, 0x10,
	0x00c0, 0x01,

};

static __u16 reg_change_day_3[] = {

	0xfffe, 0x14,
	0xfffe, 0x21,
	0x0001, 0x82,
	0x0003, 0xb1,
	0x031a, 0x00,
	0x031b, 0x00,
	0x031c, 0x00,
	0x031d, 0x00,
	0x031e, 0x18,
	0x031f, 0x1c,

	0x0320, 0x0a,
	0x0321, 0x0f,
	0x0580, 0x08,
	0x0581, 0x48,
	0x0582, 0x50,
	0x0584, 0x20,

	0xfffe, 0x14,
	0x02d4, 0x00,
	0x02d5, 0x20,
	0xfffe, 0x21,
	0x0688, 0x11,
	0x0689, 0x11,
	0x068a, 0x22,
	0x068b, 0x22,
	0x068c, 0x44,
	0x068d, 0x44,
	0x068e, 0x22,
	0x068f, 0x22,
	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0004, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x1c00, 0x01,

	0x1c01, 0x49,
	0x1c02, 0x10,

	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0007, 0x60,
	0x000d, 0x30,
	0x0009, 0x00,
	0x00c4, 0x10,
	0x00c0, 0x01,
};

static __u16 reg_change_day_4[] = {
	0xfffe, 0x14,

	0xfffe, 0x21,
	0x0001, 0x82,
	0x0003, 0xb1,
	0x031a, 0x00,
	0x031b, 0x20,
	0x031c, 0x00,
	0x031d, 0x00,
	0x031e, 0x14,
	0x031f, 0x06,
	0x0320, 0x00,
	0x0321, 0x00,
	0x0580, 0x09,
	0x0581, 0x30,
	0x0582, 0x30,
	0x0584, 0x1c,
	0x0013, 0x08,

	0xfffe, 0x14,
	0x02d4, 0x00,
	0x02d5, 0x20,
	0xfffe, 0x21,
	0x0688, 0x40,
	0x0689, 0x04,
	0x068a, 0x81,
	0x068b, 0x18,
	0x068c, 0xf8,
	0x068d, 0x8f,
	0x068e, 0x81,
	0x068f, 0x18,
	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0004, 0x00,
	0xfffd, 0x80,
	0xfffe, 0x14,
	0x1c00, 0x01,

	0x1c01, 0x49,
	0x1c02, 0x12,

	0xfffd, 0x80,
	0xfffe, 0x80,
	0x0007, 0x60,
	0x000d, 0x30,
	0x0009, 0x00,
	0x00c4, 0x10,
	0x00c0, 0x01,

};

static __u16 reg_band_50hz_reg[] = {
	0xfffe, 0x14,
	0x0094, 0x0e,
	0x0095, 0x10,

};

static __u16 reg_band_60hz_reg[] = {
	0xfffe, 0x14,
	0x0094, 0x0a,
	0x0095, 0xf0,

};

static struct cfg_array sensor_band[] = {
	{
	 .regs = reg_band_50hz_reg,
	 .size = ARRAY_SIZE(reg_band_50hz_reg),
	 },
	{
	 .regs = reg_band_60hz_reg,
	 .size = ARRAY_SIZE(reg_band_60hz_reg),
	 },
};

static int g_cur_mode = -1;

__s32 __auto_ae_compensation_proc(struct v4l2_subdev *sd)
{
	__u8 data = 0;
	__u8 data1 = 0;
	__u8 vale = 0;
	__u8 vale1 = 0;

	cci_write_a16_d8(sd, 0xfffd, 0x80);
	cci_write_a16_d8(sd, 0xfffe, 0x80);
	cci_write_a16_d8(sd, 0x0004, 0x00);
	cci_write_a16_d8(sd, 0xfffd, 0x80);
	cci_write_a16_d8(sd, 0xfffe, 0x14);
	cci_write_a16_d8(sd, 0x1c00, 0x96);
	cci_write_a16_d8(sd, 0x1c01, 0x0a);
	cci_write_a16_d8(sd, 0xfffd, 0x80);
	cci_write_a16_d8(sd, 0xfffe, 0x80);
	cci_write_a16_d8(sd, 0x0007, 0x60);
	cci_write_a16_d8(sd, 0x000d, 0x30);
	cci_write_a16_d8(sd, 0x0009, 0x00);
	cci_write_a16_d8(sd, 0x00c4, 0x10);
	cci_write_a16_d8(sd, 0x00c0, 0x01);
	cci_write_a16_d8(sd, 0xfffe, 0x14);
	cci_read_a16_d8(sd, 0x1c02, &vale);
	printk("0x1c02 0x0a val : %x\n", vale);
	cci_write_a16_d8(sd, 0xfffd, 0x80);
	cci_write_a16_d8(sd, 0xfffe, 0x80);
	cci_write_a16_d8(sd, 0x0004, 0x00);
	cci_write_a16_d8(sd, 0xfffd, 0x80);
	cci_write_a16_d8(sd, 0xfffe, 0x14);
	cci_write_a16_d8(sd, 0x1c00, 0x96);
	cci_write_a16_d8(sd, 0x1c01, 0x0b);
	cci_write_a16_d8(sd, 0xfffd, 0x80);
	cci_write_a16_d8(sd, 0xfffe, 0x80);
	cci_write_a16_d8(sd, 0x0007, 0x60);
	cci_write_a16_d8(sd, 0x000d, 0x30);
	cci_write_a16_d8(sd, 0x0009, 0x00);
	cci_write_a16_d8(sd, 0x00c4, 0x10);
	cci_write_a16_d8(sd, 0x00c0, 0x01);
	cci_write_a16_d8(sd, 0xfffe, 0x14);
	cci_read_a16_d8(sd, 0x1c02, &vale1);
	printk("0x1c02 0x0b val : %x\n", vale1);

	cci_write_a16_d8(sd, 0xfffe, 0x26);

	cci_read_a16_d8(sd, 0x0038, &vale1);
	printk("0x380b val : %x\n", vale1);
	cci_read_a16_d8(sd, 0x0039, &vale1);
	printk("0x390b val : %x\n", vale1);
	cci_read_a16_d8(sd, 0x003a, &vale1);
	printk("0x3a0b val : %x\n", vale1);
	cci_read_a16_d8(sd, 0x003b, &vale1);
	printk("0x3b0b val : %x\n", vale1);

	cci_write_a16_d8(sd, 0xfffe, 0x14);

	cci_read_a16_d8(sd, 0x002b, &data1);
	cci_read_a16_d8(sd, 0x003c, &data);
	printk("0x002b   : %x\n", data1);
	printk("0x003c   : %x\n", data);
	if (data >= 0x10 && data <= 0x18) {
		printk("change to data 1......\n");
		if (g_cur_mode != 0) {
			g_cur_mode = 0;

			block_write(sd, reg_change_day_1,
				    sizeof(reg_change_day_1) / 2);

		}

	} else if (data >= 0x28 && data <= 0x9f) {
		printk("change to data 2......\n");

		if (g_cur_mode != 1) {
			g_cur_mode = 1;
			block_write(sd, reg_change_day_2,
				    sizeof(reg_change_day_2) / 2);
		}

	} else if (data > 0xff && data <= 0xff) {

		if (g_cur_mode != 2) {
			block_write(sd, reg_change_day_3,
				    sizeof(reg_change_day_3) / 2);

			g_cur_mode = 2;
		}
	}

	return (__s32) data;

}


static int sensor_read_h42_aw6121(struct v4l2_subdev *sd, unsigned short reg,
				  unsigned char *value)
{
	int ret = 0;
	int cnt = 0;

	ret = cci_read_a16_d8(sd, reg, value);
	while (ret != 0 && cnt < 2) {
		ret = cci_read_a16_d8(sd, reg, value);
		cnt++;
	}
	if (cnt > 0)
		vfe_dev_dbg("sensor read retry=%d\n", cnt);

	return ret;
}

static int sensor_write_h42_aw6121(struct v4l2_subdev *sd, unsigned short reg,
				   unsigned char value)
{
	int ret = 0;
	int cnt = 0;
	ret = cci_write_a16_d8(sd, reg, value);
	while (ret != 0 && cnt < 2) {
		ret = cci_write_a16_d8(sd, reg, value);
		cnt++;
	}
	if (cnt > 0)
		vfe_dev_dbg("sensor write retry=%d\n", cnt);

	return ret;
}

static int sensor_write_h42_aw6121_array(struct v4l2_subdev *sd,
					 struct regval_list *regs,
					 int array_size)
{
	int i = 0;

	if (!regs)
		return 0;

	while (i < array_size) {
		if (regs->addr == REG_DLY) {
			msleep(regs->data);
		} else {
			LOG_ERR_RET(sensor_write_h42_aw6121
				    (sd, regs->addr, regs->data))
		}
		i++;
		regs++;
	}
	return 0;
}

static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
{
	return 0;
}

static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
{
	return 0;
}

static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
{
	return 0;
}

static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
{
	return 0;
}

static int sensor_s_flip(struct v4l2_subdev *sd, int value)
{
	return 0;
}

static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
{
	return -EINVAL;
}

static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
{
	return -EINVAL;
}

static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	unsigned char val;

	ret = sensor_read_h42_aw6121(sd, 0x3201, &val);
	if (ret < 0) {
		vfe_dev_err
		    ("sensor_read_h42_aw6121 err at sensor_g_autoexp!\n");
		return ret;
	}

	val = ((val & 0x20) >> 5);
	if (val == 0x01) {
		*value = V4L2_EXPOSURE_AUTO;
	} else {
		*value = V4L2_EXPOSURE_MANUAL;
	}

	info->autoexp = *value;
	return 0;
}

static int sensor_s_autoexp(struct v4l2_subdev *sd,
			    enum v4l2_exposure_auto_type value)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	unsigned char val;

	ret = sensor_read_h42_aw6121(sd, 0x3201, &val);
	if (ret < 0) {
		vfe_dev_err
		    ("sensor_read_h42_aw6121 err at sensor_s_autoexp!\n");
		return ret;
	}

	switch (value) {
	case V4L2_EXPOSURE_AUTO:
		val |= 0x20;
		break;
	case V4L2_EXPOSURE_MANUAL:
		val &= 0xdf;
		break;
	case V4L2_EXPOSURE_SHUTTER_PRIORITY:
		return -EINVAL;
	case V4L2_EXPOSURE_APERTURE_PRIORITY:
		return -EINVAL;
	default:
		return -EINVAL;
	}

	ret = sensor_write_h42_aw6121(sd, 0x3201, val);
	if (ret < 0) {
		vfe_dev_err
		    ("sensor_write_h42_aw6121 err at sensor_s_autoexp!\n");
		return ret;
	}

	mdelay(20);

	info->autoexp = value;
	return 0;
}

static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	unsigned char val;

	ret = sensor_read_h42_aw6121(sd, 0x3201, &val);
	if (ret < 0) {
		vfe_dev_err("sensor_read_h42_aw6121 err at sensor_g_autowb!\n");
		return ret;
	}

	val = ((val & 0x10) >> 4);


	*value = val;
	info->autowb = *value;

	return 0;
}

static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	unsigned char val;

	ret =
	    sensor_write_h42_aw6121_array(sd, sensor_wb_auto_regs,
					  ARRAY_SIZE(sensor_wb_auto_regs));
	if (ret < 0) {
		vfe_dev_err
		    ("sensor_write_h42_aw6121_array err at sensor_s_autowb!\n");
		return ret;
	}

	ret = sensor_read_h42_aw6121(sd, 0x3201, &val);
	if (ret < 0) {
		vfe_dev_err("sensor_read_h42_aw6121 err at sensor_s_autowb!\n");
		return ret;
	}

	switch (value) {
	case 0:
		val &= 0xef;
		break;
	case 1:
		val |= 0x10;
		break;
	default:
		break;
	}
	ret = sensor_write_h42_aw6121(sd, 0x3201, val);
	if (ret < 0) {
		vfe_dev_err
		    ("sensor_write_h42_aw6121 err at sensor_s_autowb!\n");
		return ret;
	}

	mdelay(10);

	info->autowb = value;
	return 0;
}

static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
{
	return -EINVAL;
}



static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);
	*value = info->brightness;
	return 0;
}

static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
{
	struct sensor_info *info = to_state(sd);

	if (info->brightness == value)
		return 0;

	if (value < -4 || value > 4)
		return -ERANGE;

	LOG_ERR_RET(sensor_write_h42_aw6121_array
		    (sd, sensor_brightness[value + 4].regs,
		     sensor_brightness[value + 4].size))

	    info->brightness = value;
	return 0;
}

static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);
	*value = info->saturation;
	return 0;
}

static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
{
	struct sensor_info *info = to_state(sd);
	if (info->saturation == value)
		return 0;

	if (value < -4 || value > 4)
		return -ERANGE;

	LOG_ERR_RET(sensor_write_h42_aw6121_array
		    (sd, sensor_saturation[value + 4].regs,
		     sensor_saturation[value + 4].size))

	    info->saturation = value;
	return 0;
}

static int sensor_g_exp_bias(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);
	*value = info->exp_bias;
	return 0;
}

static int sensor_s_exp_bias(struct v4l2_subdev *sd, int value)
{
	struct sensor_info *info = to_state(sd);
	if (info->exp_bias == value)
		return 0;

	if (value < -4 || value > 4)
		return -ERANGE;
	vfe_set_mclk_freq(sd, MCLK);
	vfe_set_mclk(sd, ON);
	msleep(20);
	LOG_ERR_RET(sensor_write_h42_aw6121_array
		    (sd, sensor_ev[value + 4].regs, sensor_ev[value + 4].size))

	    info->exp_bias = value;
	return 0;
}

static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
{
	struct sensor_info *info = to_state(sd);
	enum v4l2_auto_n_preset_white_balance *wb_type =
	    (enum v4l2_auto_n_preset_white_balance *)value;
	*wb_type = info->wb;

	return 0;
}

static int sensor_s_wb(struct v4l2_subdev *sd,
		       enum v4l2_auto_n_preset_white_balance value)
{
	struct sensor_info *info = to_state(sd);
	if (info->capture_mode == V4L2_MODE_IMAGE)
		return 0;

	if (info->wb == value)
		return 0;
	vfe_set_mclk_freq(sd, MCLK);
	vfe_set_mclk(sd, ON);
	msleep(20);
	LOG_ERR_RET(sensor_write_h42_aw6121_array
		    (sd, sensor_wb[value].regs, sensor_wb[value].size))

	    if (value == V4L2_WHITE_BALANCE_AUTO)
		info->autowb = 1;
	else
		info->autowb = 0;

	info->wb = value;
	return 0;
}

static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);
	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx *)value;
	*clrfx_type = info->clrfx;
	return 0;
}

static int sensor_s_hue(struct v4l2_subdev *sd, enum v4l2_colorfx value)
{
	struct sensor_info *info = to_state(sd);
	if (info->clrfx == value)
		return 0;

	LOG_ERR_RET(sensor_write_h42_aw6121_array
		    (sd, sensor_colorfx[value].regs,
		     sensor_colorfx[value].size))

	    info->clrfx = value;
	return 0;
}

static int sensor_s_resolution(struct v4l2_subdev *sd,
			       enum v4l2_resolution value)
{
	struct sensor_info *info = to_state(sd);
	if (info->resolution == value)
		return 0;

	if (value == V4L2_RESOLUTION_1080P) {
		printk("########Can't Support 1080p############\n");
		value = info->resolution;
	}

	LOG_ERR_RET(sensor_write_h42_aw6121_array
		    (sd, sensor_resolution[value].regs,
		     sensor_resolution[value].size))

	    info->resolution = value;
	return 0;
}

static int sensor_g_flash_mode(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);
	enum v4l2_flash_led_mode *flash_mode =
	    (enum v4l2_flash_led_mode *)value;
	*flash_mode = info->flash_mode;
	return 0;
}


static int sensor_power(struct v4l2_subdev *sd, int on)
{
	int ret;
	struct sensor_info *info = to_state(sd);
	ret = 0;
	switch (on) {
	case CSI_SUBDEV_PWR_ON:
		vfe_dev_dbg("CSI_SUBDEV_PWR_ON\n");

		cci_lock(sd);
		info->streaming = 0;
		vfe_gpio_set_status(sd, RESET, 1);
		vfe_gpio_set_status(sd, POWER_EN, 1);
		msleep(30);
		vfe_gpio_write(sd, POWER_EN, 1);
		vfe_gpio_write(sd, RESET, CSI_RST_OFF);
		msleep(20);
		vfe_set_mclk_freq(sd, MCLK);
		vfe_set_mclk(sd, ON);
		msleep(20);
		vfe_gpio_write(sd, RESET, CSI_RST_ON);
		msleep(20);
		vfe_gpio_write(sd, RESET, CSI_RST_OFF);
		msleep(20);
		vfe_gpio_write(sd, RESET, CSI_RST_ON);
		msleep(10);
		cci_unlock(sd);
		break;
	case CSI_SUBDEV_PWR_OFF:
		vfe_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
		cci_lock(sd);
		mdelay(10);
		vfe_gpio_set_status(sd, RESET, 1);
		mdelay(10);
		vfe_gpio_write(sd, RESET, CSI_RST_ON);
		vfe_gpio_write(sd, POWER_EN, 0);
		mdelay(10);
		vfe_set_mclk(sd, OFF);
		mdelay(10);
		cci_unlock(sd);
		break;
	default:
		return -EINVAL;
	}
	return 0;
}

static int sensor_reset(struct v4l2_subdev *sd, u32 val)
{
	switch (val) {
	case 0:
		vfe_gpio_write(sd, RESET, CSI_RST_OFF);
		mdelay(10);
		break;
	case 1:
		vfe_gpio_write(sd, RESET, CSI_RST_ON);
		mdelay(10);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

__s32 block_write(struct v4l2_subdev *sd, __u16 *reg, __u32 length)
{
	__u32 i = 0;
	__s32 ret = 0;

	if (reg[i] == 0xFF00) {
		printk("not vaild iic data!\n");
		return -1;
	}

	for (i = 0; i < length; i += reg_step) {
		if (cci_write_a16_d8(sd, reg[i], reg[i + 1] & 0x00FF) != 0) {
			ret = -1;
			break;
		} else {
		}

		if (i == 0)
			msleep(5);
	}

	return ret;
}

void h42_init_sensor(struct v4l2_subdev *sd)
{
	cci_write_a8_d8(sd, 0x12, 0x40);
	cci_write_a8_d8(sd, 0x0D, 0x40);
	cci_write_a8_d8(sd, 0x1F, 0x04);
	cci_write_a8_d8(sd, 0x0E, 0x1D);
	cci_write_a8_d8(sd, 0x0F, 0x09);
	cci_write_a8_d8(sd, 0x10, 0x1E);
	cci_write_a8_d8(sd, 0x11, 0x80);
	cci_write_a8_d8(sd, 0x19, 0x1c);
	cci_write_a8_d8(sd, 0x20, 0x40);
	cci_write_a8_d8(sd, 0x21, 0x06);
	cci_write_a8_d8(sd, 0x22, 0xEE);
	cci_write_a8_d8(sd, 0x23, 0x02);
	cci_write_a8_d8(sd, 0x24, 0x00);
	cci_write_a8_d8(sd, 0x25, 0xD0);
	cci_write_a8_d8(sd, 0x26, 0x25);

#if 1
	cci_write_a8_d8(sd, 0x27, 0x49);
	cci_write_a8_d8(sd, 0x28, 0x0d);
#else
	cci_write_a8_d8(sd, 0x27, 0x48);
	cci_write_a8_d8(sd, 0x28, 0x0e);
#endif

	cci_write_a8_d8(sd, 0x29, 0x01);
	cci_write_a8_d8(sd, 0x2A, 0x24);
	cci_write_a8_d8(sd, 0x2B, 0x29);
	cci_write_a8_d8(sd, 0x2C, 0x00);
	cci_write_a8_d8(sd, 0x2D, 0x00);
	cci_write_a8_d8(sd, 0x2E, 0xB9);
	cci_write_a8_d8(sd, 0x2F, 0x00);
	cci_write_a8_d8(sd, 0x30, 0x92);
	cci_write_a8_d8(sd, 0x31, 0x0A);
	cci_write_a8_d8(sd, 0x32, 0xAA);
	cci_write_a8_d8(sd, 0x33, 0x14);
	cci_write_a8_d8(sd, 0x34, 0x38);
	cci_write_a8_d8(sd, 0x35, 0x54);
	cci_write_a8_d8(sd, 0x42, 0x41);
	cci_write_a8_d8(sd, 0x43, 0x50);
	cci_write_a8_d8(sd, 0x1D, 0x00);
	cci_write_a8_d8(sd, 0x1E, 0x00);
	cci_write_a8_d8(sd, 0x6C, 0x50);
	cci_write_a8_d8(sd, 0x73, 0x33);
	cci_write_a8_d8(sd, 0x70, 0x68);
	cci_write_a8_d8(sd, 0x76, 0x40);
	cci_write_a8_d8(sd, 0x77, 0x06);
	cci_write_a8_d8(sd, 0x78, 0x18);
	cci_write_a8_d8(sd, 0x60, 0xA4);
	cci_write_a8_d8(sd, 0x61, 0xFF);
	cci_write_a8_d8(sd, 0x62, 0x40);
	cci_write_a8_d8(sd, 0x65, 0x00);
	cci_write_a8_d8(sd, 0x67, 0x30);
	cci_write_a8_d8(sd, 0x68, 0x04);
	cci_write_a8_d8(sd, 0x69, 0x74);
	cci_write_a8_d8(sd, 0x6F, 0x04);
	cci_write_a8_d8(sd, 0x13, 0x67);
	cci_write_a8_d8(sd, 0x14, 0x80);
	cci_write_a8_d8(sd, 0x16, 0xC0);
	cci_write_a8_d8(sd, 0x17, 0x40);
	cci_write_a8_d8(sd, 0x18, 0xE1);
	cci_write_a8_d8(sd, 0x38, 0x35);
	cci_write_a8_d8(sd, 0x39, 0x98);
	cci_write_a8_d8(sd, 0x4a, 0x03);
	cci_write_a8_d8(sd, 0x48, 0x40);
	cci_write_a8_d8(sd, 0x49, 0x0c);
	cci_write_a8_d8(sd, 0x12, 0x00);
#if 1
	cci_write_a8_d8(sd, 0x12, 0x00);
#else
	cci_write_a8_d8(sd, 0x12, 0x30);
#endif
};

#define H42_BASE_ADDR   0

void h42_gpio_init(struct v4l2_subdev *sd)
{
	printk
	    ("###################################h42_gpio_init :#####################################\n");
	vfe_gpio_set_status(sd, RESET, 1);
	vfe_gpio_set_status(sd, POWER_EN, 1);
	msleep(30);
	vfe_gpio_write(sd, POWER_EN, 1);
	vfe_gpio_write(sd, RESET, CSI_RST_OFF);
	msleep(20);
	vfe_set_mclk_freq(sd, MCLK);
	vfe_set_mclk(sd, ON);
	msleep(20);
	vfe_gpio_write(sd, RESET, CSI_RST_ON);
	msleep(20);
	vfe_gpio_write(sd, RESET, CSI_RST_OFF);
	msleep(20);
	vfe_gpio_write(sd, RESET, CSI_RST_ON);
	msleep(10);
}

void sunxi_h42_dump_regs(struct v4l2_subdev *sd)
{
	int i = 0;
	unsigned char value;
	printk
	    ("###########################################################################################\n");
	printk
	    ("###########################################################################################\n");
	printk
	    ("###########################################################################################\n");
	printk
	    ("###########################################################################################\n");
	printk
	    ("###########################################################################################\n");
	printk
	    ("###################################Vfe dump h42 regs :#####################################\n");
	for (i = 0; i < 0xff; i++) {
		if (i % 0x10 == 0)
			printk("0x%08x:    ", i);

		cci_read_a8_d8(sd, (H42_BASE_ADDR + i), &value);
		printk("0x%x, ", value);
		if (i % 0x10 == 0xc)
			printk("\n");
	}
}

#if defined(H42_REG_DUMP)
void read_h42_reg(struct v4l2_subdev *sd)
{
	unsigned char val;

	sensor_write_h42_aw6121(sd, 0xfffe, 0x26);
	cci_read_a16_d8(sd, 0x0038, &val);
	printk("read reg=[0x0038], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x0039, &val);
	printk("read reg=[0x0039], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x003a, &val);
	printk("read reg=[0x003a], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x003b, &val);
	printk("read reg=[0x003b], val=[0x%x]\n", val);

	sensor_write_h42_aw6121(sd, 0xfffe, 0x25);
	cci_read_a16_d8(sd, 0x6007, &val);
	printk("read reg=[0x6007], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x0002, &val);
	printk("read reg=[0x0002], val=[0x%x]\n", val);

	sensor_write_h42_aw6121(sd, 0xfffe, 0x80);
	cci_read_a16_d8(sd, 0x0030, &val);
	printk("read reg=[0x0030], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x0031, &val);
	printk("read reg=[0x0031], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x0032, &val);
	printk("read reg=[0x0032], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x0033, &val);
	printk("read reg=[0x0033], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x0137, &val);
	printk("read reg=[0x0137], val=[0x%x]\n", val);

	sensor_write_h42_aw6121(sd, 0xfffe, 0x25);
	cci_read_a16_d8(sd, 0x6002, &val);
	printk("read reg=[0x6002], val=[0x%x]\n", val);
	cci_read_a16_d8(sd, 0x6003, &val);
	printk("read reg=[0x6003], val=[0x%x]\n", val);

	sensor_write_h42_aw6121(sd, 0xfffe, 0x21);
	cci_read_a16_d8(sd, 0x006c, &val);
	printk("read reg=[0x006c], val=[0x%x]\n", val);
}
#endif

void h42_sensor_init(struct v4l2_subdev *sd)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int i = 0;
	vfe_dev_dbg("h42_sensor_init\n");
	h42_gpio_init(sd);
	for (i = 0; i < 1; i++) {
		client->addr = 0x36 >> 1;
		sensor_write_h42_aw6121_array(sd, sensor_default_regs,
					      ARRAY_SIZE(sensor_default_regs));

#if defined(DISP_720P)
		sensor_write_h42_aw6121_array(sd, sensor_720P_regs,
					      ARRAY_SIZE(sensor_720P_regs));
#else
		sensor_write_h42_aw6121_array(sd, sensor_vga_regs,
					      ARRAY_SIZE(sensor_vga_regs));
#endif

		sensor_write_h42_aw6121(sd, 0xfffe, 0x80);
		sensor_write_h42_aw6121(sd, 0x004D, 0x01);
		sensor_write_h42_aw6121(sd, 0x0050, 0x06);
		sensor_write_h42_aw6121(sd, 0x0054, 0x06);
		sensor_write_h42_aw6121(sd, 0x0058, 0x04);
		msleep(5);
		sensor_write_h42_aw6121(sd, 0x0058, 0x02);
		msleep(5);
		client->addr = 0x60 >> 1;
		h42_init_sensor(sd);
#if defined(H42_REG_DUMP)
		sunxi_h42_dump_regs(sd);
#endif
		client->addr = 0x36 >> 1;
		sensor_write_h42_aw6121(sd, 0xfffe, 0x80);
		sensor_write_h42_aw6121(sd, 0x004D, 0x00);
	}

#if defined(DISP_720P)
	sensor_write_h42_aw6121_array(sd, sensor_720P_regs,
				      ARRAY_SIZE(sensor_720P_regs));
#else
	sensor_write_h42_aw6121_array(sd, sensor_vga_regs,
				      ARRAY_SIZE(sensor_vga_regs));
#endif

	sensor_write_h42_aw6121(sd, 0xfffe, 0x21);
	sensor_write_h42_aw6121(sd, 0x006c, 0x20);

#if defined(H42_REG_DUMP)
	read_h42_reg(sd);
#endif
}

__s32 sensor_set_scene_auto(struct v4l2_subdev *sd)
{
	__s32 ret;
	mod_timer(&s_timer, jiffies + (HZ * 2));
	ret = __auto_ae_compensation_proc(sd);
	return ret;
}

static int sensor_g_band(struct v4l2_subdev *sd,
			 enum v4l2_power_line_frequency value)
{
	struct sensor_info *info = to_state(sd);
	enum v4l2_power_line_frequency *band_filter =
	    (enum v4l2_auto_n_preset_white_balance *)value;
	*band_filter = info->band_filter;

	return 0;
}

static int sensor_s_band(struct v4l2_subdev *sd,
			 enum v4l2_power_line_frequency value)
{

	__u16 *reg_table = NULL;
	__u32 reg_table_len = 0;
	vfe_set_mclk_freq(sd, MCLK);
	vfe_set_mclk(sd, ON);
	msleep(20);
	switch (value) {
	case V4L2_CID_POWER_LINE_FREQUENCY_50HZ:
		{

			reg_table = reg_band_50hz_reg;
			reg_table_len = sizeof(reg_band_50hz_reg) / 2;

			break;
		}
	case V4L2_CID_POWER_LINE_FREQUENCY_60HZ:
		{

			reg_table = reg_band_60hz_reg;
			reg_table_len = sizeof(reg_band_60hz_reg) / 2;

			break;
		}
	}

	block_write(sd, reg_table, reg_table_len);
	return 0;
}

static int sensor_init(struct v4l2_subdev *sd, u32 val)
{
	vfe_dev_dbg("sensor_init\n");
	h42_sensor_init(sd);
	return 0;
}

static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
{
	int ret = 0;
	return ret;
}

static struct sensor_format_struct {
	__u8 *desc;
	enum v4l2_mbus_pixelcode mbus_code;
	struct regval_list *regs;
	int regs_size;
	int bpp;
} sensor_formats[] = {
	{
		.desc = "UYVY 4:2:2", .mbus_code = V4L2_MBUS_FMT_UYVY8_2X8,
	.regs = sensor_fmt_yuv422_uyvy, .regs_size =
		    ARRAY_SIZE(sensor_fmt_yuv422_uyvy), .bpp = 2,}, {
		.desc = "YUYV 4:2:2", .mbus_code = V4L2_MBUS_FMT_YUYV8_2X8,
	.regs = sensor_fmt_yuv422_yuyv, .regs_size =
		    ARRAY_SIZE(sensor_fmt_yuv422_yuyv), .bpp = 2,}, {
		.desc = "YVYU 4:2:2", .mbus_code = V4L2_MBUS_FMT_YVYU8_2X8,
	.regs = sensor_fmt_yuv422_yvyu, .regs_size =
		    ARRAY_SIZE(sensor_fmt_yuv422_yvyu), .bpp = 2,}, {
		.desc = "VYUY 4:2:2", .mbus_code = V4L2_MBUS_FMT_VYUY8_2X8,
	.regs = sensor_fmt_yuv422_vyuy, .regs_size =
		    ARRAY_SIZE(sensor_fmt_yuv422_vyuy), .bpp = 2,}, {
		.desc = "Raw RGB Bayer", .mbus_code = V4L2_MBUS_FMT_SBGGR8_1X8,
.regs = sensor_fmt_raw, .regs_size =
		    ARRAY_SIZE(sensor_fmt_raw), .bpp = 1},};
#define N_FMTS ARRAY_SIZE(sensor_formats)


static struct sensor_win_size sensor_win_sizes[] = {

	{
	 .width = HD1080_WIDTH,
	 .height = HD1080_HEIGHT,
	 .hoffset = 0,
	 .voffset = 0,
	 .regs = sensor_1080P_regs,
	 .regs_size = ARRAY_SIZE(sensor_1080P_regs),
	 .set_size = NULL,
	 },

	{
	 .width = HD720_WIDTH,
	 .height = HD720_HEIGHT,
	 .hoffset = 0,
	 .voffset = 0,
	 .regs = sensor_720P_regs,
	 .regs_size = ARRAY_SIZE(sensor_720P_regs),
	 .set_size = NULL,
	 },

	{
	 .width = XGA_WIDTH,
	 .height = XGA_HEIGHT,
	 .hoffset = 0,
	 .voffset = 0,
	 .regs = sensor_xga_regs,
	 .regs_size = ARRAY_SIZE(sensor_xga_regs),
	 .set_size = NULL,
	 },

	{
	 .width = VGA_WIDTH,
	 .height = VGA_HEIGHT,
	 .hoffset = 0,
	 .voffset = 0,
	 .regs = sensor_vga_regs,
	 .regs_size = ARRAY_SIZE(sensor_vga_regs),
	 .set_size = NULL,
	 },

	{
	 .width = QVGA_WIDTH,
	 .height = QVGA_HEIGHT,
	 .hoffset = 0,
	 .voffset = 0,
	 .regs = sensor_qvga_regs,
	 .regs_size = ARRAY_SIZE(sensor_qvga_regs),
	 .set_size = NULL,
	 },
};

#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))

static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
			   enum v4l2_mbus_pixelcode *code)
{
	if (index >= N_FMTS)
		return -EINVAL;

	*code = sensor_formats[index].mbus_code;
	return 0;
}

static int sensor_enum_size(struct v4l2_subdev *sd,
			    struct v4l2_frmsizeenum *fsize)
{
	if (fsize->index > N_WIN_SIZES - 1)
		return -EINVAL;

	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;

	fsize->discrete.width = sensor_win_sizes[fsize->index].width;
	fsize->discrete.height = sensor_win_sizes[fsize->index].height;

	return 0;
}

static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
				   struct v4l2_mbus_framefmt *fmt,
				   struct sensor_format_struct **ret_fmt,
				   struct sensor_win_size **ret_wsize)
{
	int index;
	struct sensor_win_size *wsize;

	for (index = 0; index < N_FMTS; index++)
		if (sensor_formats[index].mbus_code == fmt->code)
			break;

	if (index >= N_FMTS) {

		index = 0;
		fmt->code = sensor_formats[0].mbus_code;
	}
	if (ret_fmt != NULL)
		*ret_fmt = sensor_formats + index;

	fmt->field = V4L2_FIELD_NONE;

	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
	     wsize++)
		if (fmt->width >= wsize->width && fmt->height >= wsize->height)
			break;

	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
		wsize--;
	if (ret_wsize != NULL)
		*ret_wsize = wsize;
	fmt->width = wsize->width;
	fmt->height = wsize->height;
	return 0;
}

static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
{
	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
}

static int sensor_g_mbus_config(struct v4l2_subdev *sd,
				struct v4l2_mbus_config *cfg)
{
	cfg->type = V4L2_MBUS_PARALLEL;
	cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL;

	return 0;
}

static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
{
	int ret;
	struct sensor_format_struct *sensor_fmt;
	struct sensor_win_size *wsize;
	struct sensor_info *info = to_state(sd);
	vfe_dev_dbg("sensor_s_fmt\n");
	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
	if (ret)
		return ret;

	sensor_write_h42_aw6121_array(sd, sensor_fmt->regs,
				      sensor_fmt->regs_size);

	ret = 0;
	if (wsize->regs) {
		ret =
		    sensor_write_h42_aw6121_array(sd, wsize->regs,
						  wsize->regs_size);
		if (ret < 0)
			return ret;
	}

	msleep(250);

	if (wsize->set_size) {
		ret = wsize->set_size(sd);
		if (ret < 0)
			return ret;
	}

	info->fmt = sensor_fmt;
	info->width = wsize->width;
	info->height = wsize->height;

	info->streaming = 1;
	info->night_mode = 0;
	return 0;
}

static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
{
	struct v4l2_captureparm *cp = &parms->parm.capture;
	struct sensor_info *info = to_state(sd);

	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		return -EINVAL;

	memset(cp, 0, sizeof(struct v4l2_captureparm));
	cp->capability = V4L2_CAP_TIMEPERFRAME;
	cp->capturemode = info->capture_mode;

	cp->timeperframe.numerator = info->tpf.numerator;
	cp->timeperframe.denominator = info->tpf.denominator;
	printk("[King]----------------- info->tpf.denominator=%d\n",
	       info->tpf.denominator);

	return 0;
}

static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
{
	struct v4l2_captureparm *cp = &parms->parm.capture;
	struct v4l2_fract *tpf = &cp->timeperframe;
	int fps = 0;

	printk("sensor_s_parm\n");
	printk("((([%d])))\n", tpf->denominator);

	fps = tpf->denominator;

	switch (fps) {
	case 30:
		printk("switch fps to 30.\n");
#if defined(DISP_720P)
		sensor_win_sizes[1].regs = sensor_720P_regs;
		sensor_win_sizes[1].regs_size = ARRAY_SIZE(sensor_720P_regs);
#else
		sensor_win_sizes[1].regs = sensor_vga_regs;
		sensor_win_sizes[1].regs_size = ARRAY_SIZE(sensor_vga_regs);
#endif
		break;
	case 25:
		printk("switch fps to 25.\n");
		break;
	case 20:
		printk("switch fps to 20.\n");
		break;
	case 15:
		printk("switch fps to 15.\n");
		break;
	default:
		printk("switch fps to nothing.\n");
		break;
	}
	return 0;
}



static int sensor_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
{



	switch (qc->id) {
	case V4L2_CID_BRIGHTNESS:
		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
	case V4L2_CID_CONTRAST:
		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
	case V4L2_CID_SATURATION:
		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
	case V4L2_CID_HUE:
		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
	case V4L2_CID_VFLIP:
	case V4L2_CID_HFLIP:
		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
	case V4L2_CID_GAIN:
		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
	case V4L2_CID_AUTOGAIN:
		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
	case V4L2_CID_EXPOSURE:
	case V4L2_CID_AUTO_EXPOSURE_BIAS:
		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
	case V4L2_CID_EXPOSURE_AUTO:
		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 1);
	case V4L2_CID_POWER_LINE_FREQUENCY:
		return v4l2_ctrl_query_fill(qc, 0, 3, 1, 0);
	case V4L2_CID_AUTO_WHITE_BALANCE:
		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
	case V4L2_CID_COLORFX:
		return v4l2_ctrl_query_fill(qc, 0, 15, 1, 0);
	case V4L2_CID_FLASH_LED_MODE:
		return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);

	}
	return -EINVAL;
}

static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	switch (ctrl->id) {
	case V4L2_CID_BRIGHTNESS:
		return sensor_g_brightness(sd, &ctrl->value);
	case V4L2_CID_CONTRAST:
	case V4L2_CID_SATURATION:
		return sensor_g_saturation(sd, &ctrl->value);
	case V4L2_CID_HUE:
		return sensor_g_hue(sd, &ctrl->value);
	case V4L2_CID_VFLIP:
		return sensor_g_vflip(sd, &ctrl->value);
	case V4L2_CID_HFLIP:
		return sensor_g_hflip(sd, &ctrl->value);
	case V4L2_CID_GAIN:
		return sensor_g_gain(sd, &ctrl->value);
	case V4L2_CID_AUTOGAIN:
		return sensor_g_autogain(sd, &ctrl->value);
	case V4L2_CID_EXPOSURE:
	case V4L2_CID_AUTO_EXPOSURE_BIAS:
		return sensor_g_exp_bias(sd, &ctrl->value);
	case V4L2_CID_EXPOSURE_AUTO:
		return sensor_g_autoexp(sd, &ctrl->value);
	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
		return sensor_g_wb(sd, &ctrl->value);
	case V4L2_CID_AUTO_WHITE_BALANCE:
		return sensor_g_autowb(sd, &ctrl->value);
	case V4L2_CID_COLORFX:
	case V4L2_CID_FLASH_LED_MODE:
		return sensor_g_flash_mode(sd, &ctrl->value);
	case V4L2_CID_POWER_LINE_FREQUENCY:
		printk("sensor_s_ctrl13g ctrl->id = %d \n", ctrl->id);
		return sensor_g_band(sd, ctrl->value);
	}
	return -EINVAL;
}

static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	struct v4l2_queryctrl qc;

	int ret;
	qc.id = ctrl->id;
	ret = sensor_queryctrl(sd, &qc);
	if (ret < 0) {
		return ret;
	}
	if (qc.type == V4L2_CTRL_TYPE_MENU ||
	    qc.type == V4L2_CTRL_TYPE_INTEGER ||
	    qc.type == V4L2_CTRL_TYPE_BOOLEAN) {
		if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
			return -ERANGE;
		}
	}

	if (ctrl->id == V4L2_CID_GAIN)
		ctrl->id = V4L2_CID_RESOLUTION;

	switch (ctrl->id) {
	case V4L2_CID_BRIGHTNESS:
		return sensor_s_brightness(sd, ctrl->value);
	case V4L2_CID_SATURATION:
		return sensor_s_saturation(sd, ctrl->value);
	case V4L2_CID_VFLIP:
		return sensor_s_vflip(sd, ctrl->value);
	case V4L2_CID_HFLIP:
		return sensor_s_hflip(sd, ctrl->value);
	case V4L2_CID_HUE:
		return sensor_s_hue(sd, (enum v4l2_colorfx)ctrl->value);
	case V4L2_CID_AUTOGAIN:
		return sensor_s_autogain(sd, ctrl->value);
	case V4L2_CID_EXPOSURE:
	case V4L2_CID_AUTO_EXPOSURE_BIAS:
		return sensor_s_exp_bias(sd, ctrl->value);
	case V4L2_CID_EXPOSURE_AUTO:
		return sensor_s_autoexp(sd,
					(enum v4l2_exposure_auto_type)
					ctrl->value);
	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
		return sensor_s_wb(sd,
				   (enum v4l2_auto_n_preset_white_balance)
				   ctrl->value);
	case V4L2_CID_AUTO_WHITE_BALANCE:
		return sensor_s_autowb(sd, ctrl->value);
	case V4L2_CID_COLORFX:
		return sensor_s_flip(sd, ctrl->value);
	case V4L2_CID_RESOLUTION:
		return sensor_s_resolution(sd, ctrl->value);
		break;
	case V4L2_CID_POWER_LINE_FREQUENCY:
		return sensor_s_band(sd, ctrl->value);
		break;
	}
	return -EINVAL;
}

static int sensor_g_chip_ident(struct v4l2_subdev *sd,
			       struct v4l2_dbg_chip_ident *chip)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);

	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
}



static const struct v4l2_subdev_core_ops sensor_core_ops = {
	.g_chip_ident = sensor_g_chip_ident,
	.g_ctrl = sensor_g_ctrl,
	.s_ctrl = sensor_s_ctrl,
	.queryctrl = sensor_queryctrl,
	.reset = sensor_reset,
	.init = sensor_init,
	.s_power = sensor_power,
	.ioctl = sensor_ioctl,
};

static const struct v4l2_subdev_video_ops sensor_video_ops = {
	.enum_mbus_fmt = sensor_enum_fmt,
	.enum_framesizes = sensor_enum_size,
	.try_mbus_fmt = sensor_try_fmt,
	.s_mbus_fmt = sensor_s_fmt,
	.s_parm = sensor_s_parm,
	.g_parm = sensor_g_parm,
	.g_mbus_config = sensor_g_mbus_config,
};

static const struct v4l2_subdev_ops sensor_ops = {
	.core = &sensor_core_ops,
	.video = &sensor_video_ops,
};

static struct cci_driver cci_drv = {
	.name = SENSOR_NAME,
	.addr_width = CCI_BITS_16,
	.data_width = CCI_BITS_8,
};

static int sensor_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	struct v4l2_subdev *sd;
	struct sensor_info *info;

	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
	if (info == NULL)
		return -ENOMEM;
	sd = &info->sd;
	cci_dev_probe_helper(sd, client, &sensor_ops, &cci_drv);

	info->fmt = &sensor_formats[0];
	info->brightness = 0;
	info->contrast = 0;
	info->saturation = 0;
	info->hue = 0;
	info->hflip = 0;
	info->vflip = 0;
	info->gain = 0;
	info->autogain = 1;
	info->exp = 0;
	info->autoexp = 0;
	info->autowb = 1;
	info->wb = 0;
	info->clrfx = 0;

	h42_aw6121 = sd;

	info->night_mode = 0;
	info->streaming = 0;

	return 0;
}

static int sensor_remove(struct i2c_client *client)
{
	struct sensor_info *info;
	struct v4l2_subdev *sd;

	del_timer(&s_timer);
	sd = cci_dev_remove_helper(client, &cci_drv);
	info = to_state(sd);
	kfree(to_state(sd));
	return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{SENSOR_NAME, 0},
	{}
};

MODULE_DEVICE_TABLE(i2c, sensor_id);

static const struct of_device_id sernsor_match[] = {
	{.compatible = "allwinner,sensor_h42_aw6121",},
	{},
};

static struct i2c_driver sensor_driver = {
	.driver = {
		   .owner = THIS_MODULE,
		   .name = SENSOR_NAME,
		   .of_match_table = sernsor_match,
		   },
	.probe = sensor_probe,
	.remove = sensor_remove,
	.id_table = sensor_id,
};

static __init int init_sensor(void)
{

	return cci_dev_init_helper(&sensor_driver);
}

static __exit void exit_sensor(void)
{
	cci_dev_exit_helper(&sensor_driver);
}

module_init(init_sensor);
module_exit(exit_sensor);
